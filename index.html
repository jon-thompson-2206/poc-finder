<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UKPN Power Lines Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin=""/>
    
    <!-- noUiSlider CSS -->
    <link rel="stylesheet" href="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.css">
    
    <!-- IBM Plex Mono font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --color-dark: #0f1112;
            --color-light: #f6f6f5;
            --color-muted: #666d70;
            --color-border: #ebeff0;
        }
        
* {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'IBM Plex Mono', monospace;
        }
        
        #map {
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }
        
        /* Override Leaflet's default grab cursors to use crosshair for measurement mode */
        #map .leaflet-container {
            cursor: crosshair;
        }
        
        #map .leaflet-grab {
            cursor: crosshair;
        }
        
        #map .leaflet-dragging .leaflet-grab {
            cursor: grabbing;
        }
        
        /* Interactive elements (cables, substations, parcels) show pointer on hover */
        #map .leaflet-interactive {
            cursor: pointer !important;
        }
        
        /* Custom Legend */
        .legend {
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
            line-height: 1.6;
            min-width: 140px;
        }
        
        .legend h4 {
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #1f2937;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 6px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #374151;
            padding: 2px 0;
        }
        
        .legend-color {
            width: 24px;
            height: 4px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.3s ease;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: #22c55e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: white;
            margin-top: 16px;
            font-size: 14px;
        }
        
        .loading-progress {
            color: rgba(255, 255, 255, 0.7);
            margin-top: 8px;
            font-size: 12px;
        }
        
        /* Popup styling */
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
        }
        
        .popup-content {
            font-size: 13px;
            line-height: 1.5;
        }
        
        .popup-content strong {
            color: #1f2937;
        }
        
        .popup-content .voltage-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: white;
            margin-bottom: 6px;
        }
        
        /* Filter Panel */
        .filter-panel {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 16px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(15, 17, 18, 0.12);
            border: 1px solid var(--color-border);
            width: 280px;
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .filter-panel h4 {
            margin: 0 0 6px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--color-dark);
        }
        
        .filter-panel .subtitle {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 16px;
        }
        
        .mva-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 10px 14px;
            background: #f3f4f6;
            border-radius: 8px;
        }
        
        .mva-value {
            text-align: center;
        }
        
        .mva-value .label {
            font-size: 10px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .mva-value .number {
            font-size: 18px;
            font-weight: 700;
            color: #1f2937;
        }
        
        .mva-separator {
            font-size: 14px;
            color: #9ca3af;
            font-weight: 500;
        }
        
        .slider-container {
            padding: 10px 8px 20px 8px;
        }
        
        /* noUiSlider custom styling */
        .noUi-target {
            background: #e5e7eb;
            border: none;
            box-shadow: none;
            height: 12px;
            border-radius: 4px;
        }
        
        .noUi-connect {
            background: var(--color-muted);
            border-radius: 4px;
        }
        
        .noUi-handle {
            width: 12px !important;
            height: 12px !important;
            border-radius: 2px !important;
            background: var(--color-dark) !important;
            border: none !important;
            box-shadow: none !important;
            cursor: grab;
            top: 0px !important;
            right: -4px !important;
            box-sizing: border-box !important;
        }
        
        .noUi-handle:before,
        .noUi-handle:after {
            display: none;
        }
        
        .noUi-handle:focus {
            outline: none;
        }
        
        .noUi-handle:active {
            cursor: grabbing;
        }
        
        /* Active layers list */
        .active-layers {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid #e5e7eb;
        }
        
        .active-layers-title {
            font-size: 11px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        
        .layer-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            font-size: 13px;
            color: #374151;
            transition: opacity 0.2s ease;
        }
        
        .layer-indicator.hidden {
            opacity: 0.35;
            text-decoration: line-through;
        }
        
        .layer-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        /* Map layer options */
        .map-layers {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid #e5e7eb;
        }
        
        .map-layers-title {
            font-size: 11px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        
        .map-layer-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
            color: #374151;
            background: transparent;
            border: 1px solid transparent;
        }
        
        .map-layer-option:hover {
            background: #f3f4f6;
        }
        
        .map-layer-option.selected {
            background: #e0e7ff;
            border-color: #6366f1;
            color: #1e40af;
            font-weight: 500;
        }
        
        .map-layer-option .shortcut {
            font-size: 11px;
            color: #9ca3af;
            font-weight: normal;
        }
        
        .map-layer-option.selected .shortcut {
            color: #6366f1;
        }
        
        .layer-mva {
            margin-left: auto;
            font-size: 11px;
            color: #9ca3af;
        }
        
        /* Slider pips */
        .noUi-pips {
            color: #9ca3af;
            font-size: 10px;
        }
        
        .noUi-pips-horizontal {
            padding: 8px 0 0 0;
            height: auto;
        }
        
        .noUi-marker-horizontal.noUi-marker-large {
            height: 8px;
        }
        
        .noUi-value {
            padding-top: 2px;
        }
        
        /* POC Mode Styles */
        .poc-mode-active {
            cursor: crosshair !important;
        }
        
        .poc-mode-active .leaflet-interactive {
            cursor: crosshair !important;
        }
        
        .poc-button {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(15, 17, 18, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
            transition: all 0.2s ease;
        }
        
        .poc-button:hover {
            background: #f9fafb;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .poc-button.active {
            background: #22c55e;
            color: white;
        }
        
        .poc-button.active:hover {
            background: #16a34a;
        }
        
        .poc-button svg {
            width: 18px;
            height: 18px;
        }
        
        /* Distance tooltip that follows cursor */
        .poc-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(15, 17, 18, 0.92);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: var(--color-light);
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            transform: translate(-50%, -100%);
            margin-top: -16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.15s ease;
            min-width: 160px;
        }
        
        .poc-tooltip.visible {
            opacity: 1;
        }
        
        .poc-tooltip .poc-tooltip-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .poc-tooltip .poc-tooltip-row:last-child {
            border-bottom: none;
        }
        
        .poc-tooltip .poc-voltage-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .poc-tooltip .poc-voltage-label {
            font-size: 12px;
            font-weight: 600;
            min-width: 45px;
        }
        
        .poc-tooltip .poc-distance-val {
            font-size: 13px;
            font-weight: 700;
            margin-left: auto;
        }
        
        .poc-tooltip.no-connection {
            background: rgba(239, 68, 68, 0.95);
        }
        
        .poc-tooltip .no-connection-msg {
            font-size: 12px;
            text-align: center;
        }
        
        /* ============== SITE & POC PANEL STYLES ============== */
        
        /* Add Site button */
        .add-site-button {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(15, 17, 18, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
            transition: all 0.2s ease;
            margin-top: 8px;
        }
        
        .add-site-button:hover {
            background: #f9fafb;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .add-site-button.active {
            background: #3b82f6;
            color: white;
        }
        
        .add-site-button.active:hover {
            background: #2563eb;
        }
        
        .add-site-button svg {
            width: 18px;
            height: 18px;
        }
        
        /* Site mode cursor */
        .add-site-mode-active {
            cursor: crosshair !important;
        }
        
        .add-site-mode-active .leaflet-interactive {
            cursor: crosshair !important;
        }
        
        /* Add POC mode cursor */
        .add-poc-mode-active {
            cursor: pointer !important;
        }
        
        .add-poc-mode-active .leaflet-interactive {
            cursor: pointer !important;
        }
        
        /* Obstacle Mode button */
        .obstacle-mode-button {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(15, 17, 18, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
            transition: all 0.2s ease;
            margin-top: 8px;
        }
        
        .obstacle-mode-button:hover {
            background: #f9fafb;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .obstacle-mode-button.active {
            background: #a855f7;
            color: white;
        }
        
        .obstacle-mode-button.active:hover {
            background: #9333ea;
        }
        
        .obstacle-mode-button svg {
            width: 18px;
            height: 18px;
        }
        
        /* Heatmap button */
        .heatmap-button {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(15, 17, 18, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
            transition: all 0.2s ease;
            margin-top: 8px;
        }
        
        .heatmap-button:hover {
            background: #f9fafb;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .heatmap-button.active {
            background: #f97316;
            color: white;
        }
        
        .heatmap-button.active:hover {
            background: #ea580c;
        }
        
        .heatmap-button svg {
            width: 18px;
            height: 18px;
        }
        
        /* Find Location button */
        .find-location-button {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(15, 17, 18, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
            transition: all 0.2s ease;
            margin-top: 8px;
        }
        
        .find-location-button:hover {
            background: #f9fafb;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .find-location-button.active {
            background: #eab308;
            color: white;
        }
        
        .find-location-button.active:hover {
            background: #ca8a04;
        }
        
        .find-location-button svg {
            width: 18px;
            height: 18px;
        }
        
        /* Find Location instruction */
        .find-location-instruction {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(234, 179, 8, 0.95);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        /* Location recommendation marker */
        .location-recommendation-marker {
            width: 28px;
            height: 28px;
            background: #eab308;
            border: 3px solid white;
            border-radius: 50%;
            color: white;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* Location results panel */
        .location-results-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(246, 246, 245, 0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 0;
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .location-results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--color-border);
            font-weight: 600;
            font-size: 12px;
        }
        
        .location-results-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--color-muted);
            padding: 0;
            line-height: 1;
        }
        
        .location-results-close:hover {
            color: var(--color-dark);
        }
        
        .location-results-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .location-result-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .location-result-item:hover {
            background: rgba(0, 0, 0, 0.03);
        }
        
        .location-result-item:last-child {
            border-bottom: none;
        }
        
        .location-result-rank {
            width: 24px;
            height: 24px;
            background: #eab308;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            flex-shrink: 0;
        }
        
        .location-result-info {
            flex: 1;
        }
        
        .location-result-score {
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
        }
        
        .location-result-detail {
            font-size: 10px;
            color: var(--color-muted);
        }
        
        .location-use-btn {
            padding: 4px 10px;
            background: var(--color-dark);
            color: var(--color-light);
            border: none;
            border-radius: 4px;
            font-size: 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .location-use-btn:hover {
            background: var(--color-muted);
        }
        
        /* Obstacle mode cursor */
        .obstacle-mode-active {
            cursor: crosshair !important;
        }
        
        .obstacle-mode-active .leaflet-interactive {
            cursor: crosshair !important;
        }
        
        /* Obstacle selection rectangle */
        .obstacle-selection-rect {
            fill: rgba(168, 85, 247, 0.2);
            stroke: #a855f7;
            stroke-width: 2;
            stroke-dasharray: 6 4;
        }
        
        /* Obstacle results panel */
        .obstacle-results {
            background: rgba(246, 246, 245, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 12px;
            margin-top: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
        }
        
        .obstacle-results-content {
            margin-bottom: 10px;
        }
        
        .obstacle-result-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }
        
        .obstacle-result-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        .obstacle-result-count {
            font-weight: 600;
        }
        
        .clear-obstacles-btn {
            width: 100%;
            padding: 8px 12px;
            background: var(--color-dark);
            color: var(--color-light);
            border: none;
            border-radius: 6px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .clear-obstacles-btn:hover {
            background: var(--color-muted);
        }
        
        .obstacle-instruction {
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 6px;
            padding: 10px;
            margin-top: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: var(--color-dark);
            text-align: center;
        }
        
        /* Add POC button in side panel */
        .add-poc-button {
            width: 100%;
            padding: 10px 16px;
            background: var(--color-dark);
            color: var(--color-light);
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            margin-top: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .add-poc-button:hover {
            background: var(--color-muted);
        }
        
        .add-poc-button.active {
            background: #dc2626;
        }
        
        .add-poc-button.active:hover {
            background: #b91c1c;
        }
        
        /* Instruction banner for add POC mode */
        .add-poc-instruction {
            background: #3b82f6;
            color: white;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 13px;
            text-align: center;
            margin-top: 12px;
        }
        
        /* Side Panel */
        .side-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            bottom: 10px;
            width: 320px;
            background: rgba(246, 246, 245, 0.88);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            box-shadow: 0 4px 24px rgba(15, 17, 18, 0.12);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            z-index: 1001;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        
        .side-panel.visible {
            display: flex;
        }
        
        .side-panel-header {
            padding: 14px 16px;
            border-bottom: 1px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        
        .side-panel-header h3 {
            font-size: 13px;
            font-weight: 600;
            color: var(--color-dark);
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .side-panel-close {
            background: none;
            border: none;
            padding: 6px;
            cursor: pointer;
            color: var(--color-muted);
            border-radius: 6px;
            transition: all 0.2s;
        }
        
        .side-panel-close:hover {
            background: var(--color-border);
            color: var(--color-dark);
        }
        
        .side-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px 16px;
        }
        
        /* Site list view */
        .site-list-controls {
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .site-list-search {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--color-border);
        }
        
        .site-list-search input {
            border: none;
            outline: none;
            background: transparent;
            flex: 1;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: var(--color-dark);
        }
        
        .site-list-search input::placeholder {
            color: var(--color-muted);
        }
        
        .site-list-sort {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            font-size: 10px;
            color: var(--color-muted);
        }
        
        .site-list-sort select {
            flex: 1;
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--color-border);
            background: rgba(255, 255, 255, 0.7);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 10px;
            color: var(--color-dark);
            cursor: pointer;
        }
        
        .site-list-sort select:focus {
            outline: none;
            border-color: var(--color-muted);
            box-shadow: 0 0 0 2px rgba(102, 109, 112, 0.15);
        }
        
        .site-list-item {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 12px 14px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .site-list-item:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: var(--color-muted);
        }
        
        .site-list-item-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--color-dark);
            margin-bottom: 6px;
        }
        
        .site-list-item-meta {
            display: flex;
            gap: 12px;
            font-size: 11px;
            color: var(--color-muted);
        }
        
        .site-list-item-voltages {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }
        
        .site-list-voltage-tag {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            color: white;
        }
        
        /* Site selector */
        .site-selector {
            margin-bottom: 16px;
        }
        
        .site-selector label {
            font-size: 10px;
            color: var(--color-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: block;
            margin-bottom: 6px;
        }
        
        .site-selector select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            font-size: 13px;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.6);
            color: #1f2937;
            background: white;
            cursor: pointer;
        }
        
        .site-selector select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Site info */
        .site-info {
            background: rgba(255, 255, 255, 0.5);
            border: 1px solid var(--color-border);
            padding: 12px 14px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .site-info-name-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .site-info-name {
            font-weight: 600;
            color: var(--color-dark);
            font-size: 14px;
            flex: 1;
        }
        
        .site-rename-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6b7280;
        }
        
        .site-rename-btn:hover {
            opacity: 1;
            color: #374151;
        }
        
        .site-info-coords {
            font-size: 12px;
            color: #6b7280;
        }
        
        .site-info-parcel {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            font-size: 11px;
            color: #6b7280;
        }
        
        .parcel-popup {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
        }
        
        .parcel-popup strong {
            display: block;
            margin-bottom: 4px;
        }
        
        .parcel-popup button {
            margin-top: 8px;
        }
        
        .site-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .site-action-btn {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            font-weight: 500;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--color-dark);
        }
        
        .site-action-btn:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: var(--color-muted);
        }
        
        .site-action-btn.danger {
            color: #dc2626;
            border-color: #fecaca;
        }
        
        .site-action-btn.danger:hover {
            background: #fef2f2;
        }
        
        /* POC section */
        .poc-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        
        .poc-section-title {
            font-size: 10px;
            color: var(--color-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .route-toggle-btn {
            padding: 4px 10px;
            font-size: 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 500;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            color: var(--color-muted);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .route-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.9);
            color: var(--color-dark);
        }
        
        .route-toggle-btn.active {
            background: var(--color-dark);
            color: var(--color-light);
            border-color: var(--color-dark);
        }
        
        .poc-count {
            background: #e5e7eb;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            color: #374151;
        }
        
        /* POC card */
        .poc-card {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        
        .poc-card:hover {
            border-color: var(--color-muted);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        .poc-card.accepted {
            border-color: #86efac;
            background: #f0fdf4;
        }
        
        .poc-card.rejected {
            border-color: #fecaca;
            background: #fef2f2;
            opacity: 0.6;
        }
        
        .poc-card {
            cursor: pointer;
        }
        
        .poc-card.focused {
            border-color: var(--color-dark);
            box-shadow: 0 0 0 2px var(--color-dark), 0 4px 12px rgba(0, 0, 0, 0.15);
            background: rgba(255, 255, 255, 0.9);
        }
        
        .show-all-btn {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 12px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            font-weight: 500;
            color: var(--color-dark);
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .show-all-btn:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: var(--color-dark);
        }
        
        .poc-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .poc-voltage-badge {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 700;
            color: white;
            text-align: center;
            min-width: 50px;
        }
        
        .poc-power-range {
            font-size: 15px;
            font-weight: 600;
            color: #111827;
        }
        
        .poc-card-info {
            flex: 1;
        }
        
        .poc-card-distance {
            font-size: 13px;
            color: #6b7280;
        }
        
        .poc-card-type {
            font-size: 12px;
            color: #6b7280;
        }
        
        .poc-custom-badge {
            background: #8b5cf6;
            color: white;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 4px;
        }
        
        /* Obstacle indicators */
        .poc-obstacles {
            padding: 10px 12px;
            margin: 8px 0;
            border-radius: 6px;
            font-size: 11px;
        }
        
        .poc-obstacles.loading {
            background: rgba(107, 114, 128, 0.1);
            color: var(--color-muted);
            font-style: italic;
        }
        
        .poc-obstacles.warning {
            background: rgba(168, 85, 247, 0.08);
            border: 1px solid rgba(168, 85, 247, 0.25);
            color: var(--color-dark);
        }
        
        .poc-obstacles.clear {
            background: rgba(34, 197, 94, 0.08);
            color: #15803d;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .obstacle-clear-icon {
            color: #22c55e;
            font-weight: bold;
        }
        
        .obstacle-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(168, 85, 247, 0.15);
        }
        
        .obstacle-warning-icon {
            color: #a855f7;
        }
        
        .obstacle-summary {
            font-weight: 600;
            color: #7c3aed;
            font-size: 12px;
        }
        
        .obstacle-detail-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .obstacle-detail-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 4px;
            font-size: 11px;
        }
        
        .obstacle-type-icon {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .obstacle-detail-name {
            flex: 1;
            color: #374151;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .obstacle-detail-count {
            font-size: 10px;
            color: #6b7280;
            background: rgba(0, 0, 0, 0.06);
            padding: 1px 5px;
            border-radius: 3px;
        }
        
        .poc-card.has-crossings {
            border-color: rgba(168, 85, 247, 0.4);
        }
        
        /* Obstacle crossing marker on map - black circle */
        .obstacle-crossing-marker {
            width: 8px;
            height: 8px;
            background: var(--color-dark);
            border: 1.5px solid white;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .poc-card-actions {
            display: flex;
            gap: 8px;
        }
        
        .poc-action-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .poc-action-btn.accept {
            background: #dcfce7;
            color: #166534;
        }
        
        .poc-action-btn.accept:hover {
            background: #bbf7d0;
        }
        
        .poc-action-btn.reject {
            background: #fee2e2;
            color: #dc2626;
        }
        
        .poc-action-btn.reject:hover {
            background: #fecaca;
        }
        
        .poc-action-btn.undo {
            background: #f3f4f6;
            color: #374151;
        }
        
        .poc-action-btn.undo:hover {
            background: #e5e7eb;
        }
        
        /* Loading state */
        .poc-loading {
            text-align: center;
            padding: 40px 20px;
            color: #6b7280;
        }
        
        .poc-loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 12px;
        }
        
        /* Empty state */
        .poc-empty {
            text-align: center;
            padding: 40px 20px;
            color: #6b7280;
        }
        
        .poc-empty svg {
            width: 48px;
            height: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        
        /* Site marker custom icon - black pin */
        .site-marker-icon {
            width: 24px;
            height: 32px;
            position: relative;
        }
        .site-marker-icon::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: #1f2937;
            border: 2px solid white;
            border-radius: 50% 50% 50% 0;
            transform: translateX(-50%) rotate(-45deg);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }
        .site-marker-icon::after {
            content: '';
            position: absolute;
            top: 6px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
        }
        
        /* Substation marker - square with rounded edges */
        .substation-marker {
            border: 2px solid white;
            border-radius: 3px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- POC Mode distance tooltip -->
    <div class="poc-tooltip" id="poc-tooltip">
        <div id="poc-tooltip-content"></div>
    </div>
    
    <div class="loading-overlay" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading power line data...</div>
        <div class="loading-progress" id="loading-progress">0 / 5 layers loaded</div>
    </div>
    
    <!-- Side Panel for POCs -->
    <div class="side-panel" id="side-panel">
        <div class="side-panel-header">
            <h3>Sites</h3>
            <button class="side-panel-close" onclick="deselectSite()">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="side-panel-content" id="side-panel-content">
            <!-- Content populated by JavaScript -->
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
            crossorigin=""></script>
    
    <!-- Leaflet Heat Plugin -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    
    <!-- PDF Generation Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- noUiSlider JS -->
    <script src="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.js"></script>
    
    <!-- Turf.js for geometric calculations -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    
    <!-- Proj4js for coordinate transformation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.2/proj4.js"></script>
    
    <script>
        // Configuration
        const CONFIG = {
            // Map center (roughly center of UKPN coverage area)
            center: [51.5, 0.1],
            zoom: 9,
            minZoom: 6,
            maxZoom: 18
        };

        // Layer definitions with colors, file paths, and MVA ranges
        const LAYERS = [
            {
                name: '33kV',
                file: 'ukpn-33kv-overhead-lines.geojson',
                color: '#22c55e',  // Green
                weight: 2,
                mvaMin: 3,
                mvaMax: 30
            },
            {
                name: '66kV',
                file: 'ukpn-66kv-overhead-lines.geojson',
                color: '#22c55e',  // Green
                weight: 2,
                mvaMin: 20,
                mvaMax: 60
            },
            {
                name: '132kV',
                file: 'ukpn-132kv-overhead-lines.geojson',
                color: '#f97316',  // Orange
                weight: 2.5,
                mvaMin: 20,
                mvaMax: 100
            }
        ];
        
        // Substation layer definitions (from grid-and-primary-sites only)
        // Note: sitevoltage is the PRIMARY (input) voltage, we label by SECONDARY (output) voltage
        const SUBSTATION_LAYERS = [
            {
                name: '11kV Substations',
                file: 'grid-and-primary-sites.geojson',
                // sitevoltage 6, 11, 20, 22, 33 all output 11kV
                voltageFilter: (v) => {
                    const num = parseFloat(v);
                    return num === 6 || num === 11 || num === 20 || num === 22 || num === 33;
                },
                color: '#ef4444',  // Red
                mvaMin: 0.3,
                mvaMax: 5,
                isSubstation: true
            },
            {
                name: '33kV Substations',
                file: 'grid-and-primary-sites.geojson',
                // sitevoltage 132 outputs 33kV
                voltageFilter: (v) => parseFloat(v) === 132 || v === 132,
                color: '#22c55e',  // Green
                mvaMin: 3,
                mvaMax: 30,
                isSubstation: true
            },
            {
                name: '66kV Substations',
                file: 'grid-and-primary-sites.geojson',
                voltageFilter: (v) => parseFloat(v) === 66 || v === 66,
                color: '#22c55e',  // Green
                mvaMin: 20,
                mvaMax: 60,
                isSubstation: true
            },
            {
                name: '132kV GSPs',
                file: 'ukpn-grid-supply-points-overview.geojson',
                voltageFilter: () => true,  // All GSPs are 132kV
                color: '#f97316',  // Orange
                mvaMin: 20,
                mvaMax: 100,
                isSubstation: true,
                isGSP: true
            }
        ];
        
        // Base radius for substations at zoom level 12 (will scale with zoom)
        const SUBSTATION_BASE_RADIUS = 8;
        const SUBSTATION_MIN_RADIUS = 2;
        const SUBSTATION_MAX_RADIUS = 12;
        
        // Combined layers for display purposes
        const ALL_LAYERS = [...LAYERS, ...SUBSTATION_LAYERS];
        
        // Current filter range (default: 10-20 MVA)
        let filterMin = 10;
        let filterMax = 20;
        
        // POC search constants
        const POC_MAX_DISTANCE_KM = 30;
        
        // One-off POC click visuals (default mode)
        let singlePocLines = {};
        let singlePocMarkers = {};
        let singlePocPopup = null;
        let singlePocClickLocation = null;  // Store last click location for "Add Site" button
        let singlePocResults = [];          // Current displayed results
        let singlePocOriginalResults = [];  // Original results for reset
        let singlePocSkipped = {};          // Track skipped features per voltage-type: { '11kV-Cable': [[lng,lat], ...], ... }
        
        // Store raw GeoJSON data for Turf.js calculations
        const rawGeoJSONData = {};
        
        // ============== SITE STATE ==============
        let sites = [];  // Array of saved sites
        let currentSiteId = null;  // Currently selected site
        let siteMarkers = {};  // Map of site ID to marker
        let pocMarkers = {};  // Map of POC ID to marker
        let pocLines = {};  // Map of POC ID to connection line
        let obstacleCrossingMarkers = {};  // Map of POC ID to array of crossing markers
        let obstaclesCache = {};  // Cache: pocId -> { crossings: [], fetched: boolean }
        let obstacleOverlays = {};  // Map of POC ID to array of obstacle overlay polygons
        
        // Focus mode state
        let focusedPocId = null;  // Currently focused POC ID
        let focusHighlightLayer = null;  // Temporary layer showing focused cable/substation
        
        // Voltage levels and their power capacities (MVA)
        const VOLTAGE_POWER_RANGES = {
            '11kV': { min: 0.3, max: 5, color: '#ef4444' },
            '33kV': { min: 3, max: 30, color: '#22c55e' },
            '66kV': { min: 20, max: 60, color: '#22c55e' },
            '132kV': { min: 20, max: 100, color: '#f97316' }
        };
        
        // Initialize map
        const map = L.map('map', {
            center: CONFIG.center,
            zoom: CONFIG.zoom,
            minZoom: CONFIG.minZoom,
            maxZoom: CONFIG.maxZoom
        });

        // Base map layers
        const baseMaps = {
            'Light': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/attributions">CARTO</a> | UKPN Network Data',
                subdomains: 'abcd',
                maxZoom: 20
            }),
            'Colour': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors | UKPN Network Data',
                maxZoom: 19
            }),
            'Satellite': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '&copy; <a href="https://www.esri.com/">Esri</a> | UKPN Network Data',
                maxZoom: 19
            })
        };

        // Add Light as default
        baseMaps['Light'].addTo(map);
        
        // Track current base map
        let currentBaseMap = 'Light';

        // Layer groups for control
        const layerGroups = {};
        const substationLayerGroups = {};
        let loadedCount = 0;
        let allBounds = null;
        
        // Cache for loaded GeoJSON files (to avoid reloading same file)
        const geoJSONCache = {};
        
        // Total layers to load (cables + unique substation files)
        const TOTAL_LAYERS = LAYERS.length + 2; // 3 cable layers + 2 substation files (grid-and-primary + GSPs)

        // Create popup content for cables
        function createPopupContent(properties, layerConfig) {
            const voltage = properties.voltage || layerConfig.name;
            const dno = properties.dno || 'Unknown';
            const localAuth = properties.local_authority || 'Unknown';
            const obClass = properties.ob_class || '';
            
            return `
                <div class="popup-content">
                    <span class="voltage-badge" style="background-color: ${layerConfig.color}">${voltage}</span>
                    <div><strong>Type:</strong> ${obClass}</div>
                    <div><strong>DNO:</strong> ${dno}</div>
                    <div><strong>Area:</strong> ${localAuth}</div>
                </div>
            `;
        }
        
        // Create popup content for substations
        function createSubstationPopupContent(properties, layerConfig) {
            // Handle GSPs
            if (layerConfig.isGSP) {
                const name = properties.gsp || 'GSP';
                const dno = properties.dno || 'Unknown';
                const importLimit = properties.asset_import_limit || 'N/A';
                const exportLimit = properties.asset_export_limit || 'N/A';
                
                return `
                    <div class="popup-content">
                        <span class="voltage-badge" style="background-color: ${layerConfig.color}">132kV</span>
                        <div><strong>Name:</strong> ${name}</div>
                        <div><strong>Type:</strong> Grid Supply Point</div>
                        <div><strong>DNO:</strong> ${dno}</div>
                        <div><strong>Import Limit:</strong> ${importLimit} MVA</div>
                        <div><strong>Export Limit:</strong> ${exportLimit} MVA</div>
                    </div>
                `;
            }
            
            // Handle grid/primary substations
            const name = properties.sitename || properties.substationalias || 'Substation';
            // Use the layer config name for voltage label (this is the OUTPUT voltage, not the raw data)
            const voltage = layerConfig.name.replace(' Substations', '').replace(' GSPs', '');
            const siteType = properties.sitetype || properties.substationdesign || 'Substation';
            const dno = properties.licencearea || properties.dno || 'Unknown';
            const localAuth = properties.local_authority || properties.localauthority || 'Unknown';
            
            return `
                <div class="popup-content">
                    <span class="voltage-badge" style="background-color: ${layerConfig.color}">${voltage}</span>
                    <div><strong>Name:</strong> ${name}</div>
                    <div><strong>Type:</strong> ${siteType}</div>
                    <div><strong>DNO:</strong> ${dno}</div>
                    <div><strong>Area:</strong> ${localAuth}</div>
                </div>
            `;
        }

        // Load a GeoJSON layer
        async function loadLayer(layerConfig) {
            try {
                const response = await fetch(layerConfig.file);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                
                // Store raw GeoJSON for POC mode calculations
                rawGeoJSONData[layerConfig.name] = data;
                
                const layer = L.geoJSON(data, {
                    style: {
                        color: layerConfig.color,
                        weight: layerConfig.weight,
                        opacity: 0.8
                    },
                    onEachFeature: (feature, layer) => {
                        layer.bindPopup(createPopupContent(feature.properties, layerConfig));
                    }
                });
                
                layerGroups[layerConfig.name] = layer;
                layer.addTo(map);
                
                // Extend bounds
                const layerBounds = layer.getBounds();
                if (layerBounds.isValid()) {
                    if (allBounds === null) {
                        allBounds = layerBounds;
                    } else {
                        allBounds.extend(layerBounds);
                    }
                }
                
                loadedCount++;
                updateProgress();
                
                return true;
            } catch (error) {
                console.error(`Failed to load ${layerConfig.name}:`, error);
                loadedCount++;
                updateProgress();
                return false;
            }
        }

        // Update loading progress
        function updateProgress() {
            const progressEl = document.getElementById('loading-progress');
            progressEl.textContent = `${loadedCount} / ${TOTAL_LAYERS} layers loaded`;
            
            if (loadedCount === TOTAL_LAYERS) {
                finishLoading();
            }
        }
        
        // Load substation GeoJSON and create filtered layers
        async function loadSubstationFile(file) {
            // Return cached data if already loaded
            if (geoJSONCache[file]) {
                return geoJSONCache[file];
            }
            
            try {
                const response = await fetch(file);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                geoJSONCache[file] = data;
                return data;
            } catch (error) {
                console.error(`Failed to load ${file}:`, error);
                return null;
            }
        }
        
        // Get voltage value from substation properties
        function getSubstationVoltage(properties) {
            // Grid/Primary sites use sitevoltage (number)
            if (properties.sitevoltage !== undefined) {
                return properties.sitevoltage;
            }
            // Secondary sites use substationvoltage (string like "11kV")
            if (properties.substationvoltage) {
                return properties.substationvoltage;
            }
            return null;
        }
        
        // Calculate substation marker radius based on zoom level
        function getSubstationRadius(zoom) {
            // At zoom 6 (min): 2px, at zoom 12+: 8px, interpolate between
            const minZoom = 6;
            const maxZoom = 12;
            
            if (zoom <= minZoom) return SUBSTATION_MIN_RADIUS;
            if (zoom >= maxZoom) return SUBSTATION_BASE_RADIUS;
            
            // Linear interpolation
            const t = (zoom - minZoom) / (maxZoom - minZoom);
            return SUBSTATION_MIN_RADIUS + t * (SUBSTATION_BASE_RADIUS - SUBSTATION_MIN_RADIUS);
        }
        
        // Create a substation divIcon with given size and color
        function createSubstationIcon(size, color) {
            return L.divIcon({
                className: '',
                html: `<div class="substation-marker" style="width:${size}px;height:${size}px;background:${color};"></div>`,
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });
        }
        
        // Update all substation marker sizes based on current zoom
        function updateSubstationSizes() {
            const size = getSubstationRadius(map.getZoom()) * 2;  // Convert radius to size
            
            Object.entries(substationLayerGroups).forEach(([name, layerGroup]) => {
                const layerConfig = getLayerConfig(name);
                if (!layerConfig) return;
                
                if (layerGroup && layerGroup.eachLayer) {
                    layerGroup.eachLayer(marker => {
                        if (marker.setIcon) {
                            marker.setIcon(createSubstationIcon(size, layerConfig.color));
                        }
                    });
                }
            });
        }
        
        // Load and filter substations for a specific layer config
        async function loadSubstationLayer(layerConfig) {
            const data = await loadSubstationFile(layerConfig.file);
            if (!data || !data.features) return;
            
            // Filter features matching this voltage level (GSPs use all features)
            const filteredFeatures = layerConfig.isGSP 
                ? data.features 
                : data.features.filter(feature => {
                    const voltage = getSubstationVoltage(feature.properties);
                    if (voltage === null) return false;
                    return layerConfig.voltageFilter(voltage);
                });
            
            if (filteredFeatures.length === 0) return;
            
            // Store filtered GeoJSON for POC mode
            rawGeoJSONData[layerConfig.name] = {
                type: 'FeatureCollection',
                features: filteredFeatures
            };
            
            // Create layer group for these substations
            const layerGroup = L.layerGroup();
            const currentSize = getSubstationRadius(map.getZoom()) * 2;  // Convert radius to size
            
            filteredFeatures.forEach(feature => {
                if (!feature.geometry || feature.geometry.type !== 'Point') return;
                
                const coords = feature.geometry.coordinates;
                const marker = L.marker([coords[1], coords[0]], {
                    icon: createSubstationIcon(currentSize, layerConfig.color)
                });
                
                marker.bindPopup(createSubstationPopupContent(feature.properties, layerConfig));
                layerGroup.addLayer(marker);
            });
            
            substationLayerGroups[layerConfig.name] = layerGroup;
            layerGroup.addTo(map);
        }
        
        // Load all substations
        async function loadAllSubstations() {
            // Load both substation files
            await Promise.all([
                loadSubstationFile('grid-and-primary-sites.geojson'),
                loadSubstationFile('ukpn-grid-supply-points-overview.geojson')
            ]);
            
            loadedCount += 2;
            updateProgress();
            
            // Now create filtered layers for each substation type
            for (const layerConfig of SUBSTATION_LAYERS) {
                await loadSubstationLayer(layerConfig);
            }
        }

        // Check if ranges overlap
        function rangesOverlap(userMin, userMax, layerMin, layerMax) {
            return userMin <= layerMax && userMax >= layerMin;
        }
        
        // Format MVA value for display
        function formatMVA(value) {
            if (value >= 1) {
                return value.toFixed(0);
            }
            return value.toFixed(1);
        }
        
        // Update layer visibility based on current filter
        function updateLayerVisibility() {
            // Update cable layers
            LAYERS.forEach(layerConfig => {
                const layer = layerGroups[layerConfig.name];
                if (!layer) return;
                
                const shouldShow = rangesOverlap(filterMin, filterMax, layerConfig.mvaMin, layerConfig.mvaMax);
                const indicator = document.getElementById(`indicator-${layerConfig.name.replace(/[^a-zA-Z0-9]/g, '')}`);
                
                if (shouldShow) {
                    if (!map.hasLayer(layer)) {
                        map.addLayer(layer);
                    }
                    if (indicator) indicator.classList.remove('hidden');
                } else {
                    if (map.hasLayer(layer)) {
                        map.removeLayer(layer);
                    }
                    if (indicator) indicator.classList.add('hidden');
                }
            });
            
            // Update substation layers
            SUBSTATION_LAYERS.forEach(layerConfig => {
                const layer = substationLayerGroups[layerConfig.name];
                if (!layer) return;
                
                const shouldShow = rangesOverlap(filterMin, filterMax, layerConfig.mvaMin, layerConfig.mvaMax);
                const indicator = document.getElementById(`indicator-${layerConfig.name.replace(/[^a-zA-Z0-9]/g, '')}`);
                
                if (shouldShow) {
                    if (!map.hasLayer(layer)) {
                        map.addLayer(layer);
                    }
                    if (indicator) indicator.classList.remove('hidden');
                } else {
                    if (map.hasLayer(layer)) {
                        map.removeLayer(layer);
                    }
                    if (indicator) indicator.classList.add('hidden');
                }
            });
        }
        
        // Update the MVA display values
        function updateMVADisplay() {
            document.getElementById('mva-min').textContent = formatMVA(filterMin);
            document.getElementById('mva-max').textContent = formatMVA(filterMax);
        }
        
        // ============== POC MODE FUNCTIONS ==============
        
        // Format distance for display (auto: meters < 1km, else km)
        function formatDistance(meters) {
            if (meters < 1000) {
                return `${Math.round(meters)}m`;
            }
            return `${(meters / 1000).toFixed(2)}km`;
        }
        
        // Throttle function for performance
        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }
        
        // Get visible layer names (filtered by MVA) - includes both cables and substations
        function getVisibleLayerNames() {
            const cableNames = LAYERS
                .filter(l => rangesOverlap(filterMin, filterMax, l.mvaMin, l.mvaMax))
                .map(l => l.name);
            const substationNames = SUBSTATION_LAYERS
                .filter(l => rangesOverlap(filterMin, filterMax, l.mvaMin, l.mvaMax))
                .map(l => l.name);
            return [...cableNames, ...substationNames];
        }
        
        // Get layer config by name (from either cables or substations)
        function getLayerConfig(name) {
            return LAYERS.find(l => l.name === name) || SUBSTATION_LAYERS.find(l => l.name === name);
        }
        
        // Find nearest point on all visible cables and substations within 30km
        function findNearestConnection(cursorLat, cursorLng) {
            const cursorPoint = turf.point([cursorLng, cursorLat]);
            const visibleLayerNames = getVisibleLayerNames();
            
            let nearestResult = null;
            let nearestDistance = Infinity;
            let nearestLayerConfig = null;
            
            // Create a bounding box for 30km search radius
            const searchBuffer = turf.buffer(cursorPoint, POC_MAX_DISTANCE_KM, { units: 'kilometers' });
            const searchBbox = turf.bbox(searchBuffer);
            
            visibleLayerNames.forEach(layerName => {
                const geoJSON = rawGeoJSONData[layerName];
                if (!geoJSON || !geoJSON.features) return;
                
                const layerConfig = getLayerConfig(layerName);
                if (!layerConfig) return;
                
                geoJSON.features.forEach(feature => {
                    if (!feature.geometry) return;
                    
                    // Quick bounding box check for performance
                    const featureBbox = turf.bbox(feature);
                    if (featureBbox[0] > searchBbox[2] || featureBbox[2] < searchBbox[0] ||
                        featureBbox[1] > searchBbox[3] || featureBbox[3] < searchBbox[1]) {
                        return; // Skip features outside search area
                    }
                    
                    try {
                        // Handle Point geometries (substations)
                        if (feature.geometry.type === 'Point') {
                            const distance = turf.distance(cursorPoint, feature, { units: 'meters' });
                            
                            if (distance < nearestDistance && distance <= POC_MAX_DISTANCE_KM * 1000) {
                                nearestDistance = distance;
                                nearestResult = turf.point(feature.geometry.coordinates);
                                nearestLayerConfig = layerConfig;
                            }
                            return;
                        }
                        
                        // Handle LineString and MultiLineString (cables)
                        let lines = [];
                        if (feature.geometry.type === 'LineString') {
                            lines = [feature];
                        } else if (feature.geometry.type === 'MultiLineString') {
                            lines = feature.geometry.coordinates.map(coords => 
                                turf.lineString(coords)
                            );
                        }
                        
                        lines.forEach(line => {
                            const nearest = turf.nearestPointOnLine(line, cursorPoint, { units: 'meters' });
                            const distance = nearest.properties.dist;
                            
                            if (distance < nearestDistance && distance <= POC_MAX_DISTANCE_KM * 1000) {
                                nearestDistance = distance;
                                nearestResult = nearest;
                                nearestLayerConfig = layerConfig;
                            }
                        });
                    } catch (e) {
                        // Skip invalid geometries
                    }
                });
            });
            
            if (nearestResult && nearestDistance <= POC_MAX_DISTANCE_KM * 1000) {
                return {
                    point: nearestResult,
                    distance: nearestDistance,
                    layerConfig: nearestLayerConfig
                };
            }
            
            return null;
        }
        
        // Find nearest point on cables of a specific voltage (for snapping when dragging POC endpoint)
        function findNearestCablePoint(lat, lng, voltage, preferredLayerName) {
            const cursorPoint = turf.point([lng, lat]);
            let nearestPoint = null;
            let nearestDistance = Infinity;
            
            // First try the preferred layer (original cable)
            const layersToSearch = [];
            if (preferredLayerName && rawGeoJSONData[preferredLayerName]) {
                layersToSearch.push(preferredLayerName);
            }
            
            // Also search other layers with same voltage
            Object.keys(rawGeoJSONData).forEach(layerName => {
                if (layerName !== preferredLayerName && extractVoltage(layerName) === voltage) {
                    layersToSearch.push(layerName);
                }
            });
            
            layersToSearch.forEach(layerName => {
                const geoJSON = rawGeoJSONData[layerName];
                if (!geoJSON || !geoJSON.features) return;
                
                geoJSON.features.forEach(feature => {
                    if (!feature.geometry) return;
                    
                    try {
                        let candidatePoint = null;
                        let candidateDistance = Infinity;
                        
                        if (feature.geometry.type === 'LineString') {
                            const nearestOnLine = turf.nearestPointOnLine(feature, cursorPoint, { units: 'meters' });
                            candidateDistance = nearestOnLine.properties.dist;
                            candidatePoint = {
                                lat: nearestOnLine.geometry.coordinates[1],
                                lng: nearestOnLine.geometry.coordinates[0]
                            };
                        } else if (feature.geometry.type === 'MultiLineString') {
                            feature.geometry.coordinates.forEach(lineCoords => {
                                try {
                                    const line = turf.lineString(lineCoords);
                                    const nearestOnLine = turf.nearestPointOnLine(line, cursorPoint, { units: 'meters' });
                                    if (nearestOnLine.properties.dist < candidateDistance) {
                                        candidateDistance = nearestOnLine.properties.dist;
                                        candidatePoint = {
                                            lat: nearestOnLine.geometry.coordinates[1],
                                            lng: nearestOnLine.geometry.coordinates[0]
                                        };
                                    }
                                } catch (e) {}
                            });
                        } else if (feature.geometry.type === 'Point') {
                            // For substations, snap to the point
                            const coords = feature.geometry.coordinates;
                            candidateDistance = turf.distance(cursorPoint, feature, { units: 'meters' });
                            candidatePoint = { lat: coords[1], lng: coords[0] };
                        }
                        
                        if (candidatePoint && candidateDistance < nearestDistance) {
                            nearestDistance = candidateDistance;
                            nearestPoint = candidatePoint;
                        }
                    } catch (e) {}
                });
            });
            
            return nearestPoint;
        }
        
        // Clear one-off POC visuals and all state
        function clearSinglePOC() {
            clearSinglePOCVisuals();
            singlePocClickLocation = null;
            singlePocResults = [];
            singlePocOriginalResults = [];
            singlePocSkipped = {};
        }
        
        // Reverse geocode to get address from coordinates
        async function reverseGeocode(lat, lng) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=16&addressdetails=1`, {
                    headers: { 'User-Agent': 'POC-Finder-App' }
                });
                
                if (!response.ok) return null;
                
                const data = await response.json();
                if (data && data.address) {
                    // Build a short address from components
                    const addr = data.address;
                    const parts = [];
                    
                    // Try to get road/place name
                    if (addr.road) parts.push(addr.road);
                    else if (addr.hamlet) parts.push(addr.hamlet);
                    else if (addr.village) parts.push(addr.village);
                    else if (addr.suburb) parts.push(addr.suburb);
                    
                    // Add locality
                    if (addr.village && !parts.includes(addr.village)) parts.push(addr.village);
                    else if (addr.town) parts.push(addr.town);
                    else if (addr.city) parts.push(addr.city);
                    
                    if (parts.length > 0) {
                        return parts.slice(0, 2).join(', ');
                    }
                }
                return null;
            } catch (e) {
                console.warn('Reverse geocoding failed:', e);
                return null;
            }
        }
        
        // Generate default site name from coordinates
        function generateSiteName(lat, lng) {
            return `Site at ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
        }
        
        // Add site from single POC click location
        async function addSiteFromSinglePOC() {
            if (!singlePocClickLocation) return;
            
            const lat = singlePocClickLocation.lat;
            const lng = singlePocClickLocation.lng;
            
            // Generate a temporary name while we fetch the address
            let siteName = generateSiteName(lat, lng);
            
            // Create the site immediately with coordinate-based name
            const site = {
                id: generateId(),
                name: siteName,
                lat: lat,
                lng: lng,
                pocs: []
            };
            
            sites.push(site);
            saveSitesToStorage();
            
            // Add marker
            siteMarkers[site.id] = createSiteMarker(site);
            siteMarkers[site.id].addTo(map);
            
            // Clear the single POC visuals
            clearSinglePOC();
            
            // Select and discover POCs
            selectSite(site.id);
            discoverPOCs(site.id);
            
            // Try to get a better name from reverse geocoding (async)
            const address = await reverseGeocode(lat, lng);
            if (address) {
                site.name = address;
                saveSitesToStorage();
                
                // Update marker popup
                if (siteMarkers[site.id]) {
                    siteMarkers[site.id].setPopupContent(`<strong>${site.name}</strong><br>Click to view POCs`);
                }
                
                // Update side panel if this site is selected
                if (currentSiteId === site.id) {
                    renderSidePanel();
                }
            }
        }
        
        // Rename a site
        function renameSite(siteId) {
            const site = sites.find(s => s.id === siteId);
            if (!site) return;
            
            const newName = prompt('Enter new site name:', site.name);
            if (newName && newName.trim() !== '' && newName.trim() !== site.name) {
                site.name = newName.trim();
                saveSitesToStorage();
                
                // Update marker popup
                if (siteMarkers[siteId]) {
                    siteMarkers[siteId].setPopupContent(`<strong>${site.name}</strong><br>Click to view POCs`);
                }
                
                // Update side panel
                renderSidePanel();
            }
        }
        
        // Handle default map click: one-time POC calculation
        function handleSinglePOCClick(e) {
            
            // Also ignore clicks inside controls
            if (e.originalEvent && e.originalEvent.target.closest && e.originalEvent.target.closest('.leaflet-control')) {
                return;
            }
            
            // Run one-off POC calculation at click location
            runSinglePOCAt(e.latlng);
        }
        
        // Run one-off POC calculation at a given point
        function runSinglePOCAt(latlng, isReset = true) {
            // Clear any existing visuals
            clearSinglePOCVisuals();
            
            // Store click location for "Add Site" button
            singlePocClickLocation = { lat: latlng.lat, lng: latlng.lng };
            
            // Reset skipped if this is a fresh click (not a shuffle)
            if (isReset) {
                singlePocSkipped = {};
            }
            
            // Find nearest connections per voltage, excluding skipped
            const results = findSinglePOCResults(latlng.lat, latlng.lng);
            
            // Store results
            singlePocResults = results;
            if (isReset) {
                singlePocOriginalResults = JSON.parse(JSON.stringify(results));
            }
            
            if (results.length === 0) {
                // No connections found within range - show simple popup
                singlePocPopup = L.popup()
                    .setLatLng(latlng)
                    .setContent(`<div style="font-family: 'IBM Plex Mono', monospace; font-size: 12px;">No connections found within 30km.</div>`)
                    .openOn(map);
                return;
            }
            
            // Draw and show popup
            renderSinglePOCVisuals(results, latlng);
        }
        
        // Find POC results excluding skipped features
        function findSinglePOCResults(lat, lng) {
            const results = [];
            const sitePoint = turf.point([lng, lat]);
            const visibleLayerNames = getVisibleLayerNames();
            const searchBuffer = turf.buffer(sitePoint, POC_MAX_DISTANCE_KM, { units: 'kilometers' });
            const searchBbox = turf.bbox(searchBuffer);
            
            // Track nearest per voltage-type
            const nearestMap = {};
            
            visibleLayerNames.forEach(layerName => {
                const geoJSON = rawGeoJSONData[layerName];
                if (!geoJSON || !geoJSON.features) return;
                
                const layerConfig = getLayerConfig(layerName);
                if (!layerConfig) return;
                
                const voltage = extractVoltage(layerName);
                if (!voltage) return;
                
                const isSubstation = layerConfig.isSubstation || layerConfig.isGSP;
                const type = isSubstation ? 'Substation' : 'Cable';
                // Use just voltage as key - find nearest cable OR substation per voltage
                const key = voltage;
                const skippedPoints = singlePocSkipped[key] || [];
                
                geoJSON.features.forEach((feature) => {
                    if (!feature.geometry) return;
                    
                    // Quick bounding box check
                    const featureBbox = turf.bbox(feature);
                    if (featureBbox[0] > searchBbox[2] || featureBbox[2] < searchBbox[0] ||
                        featureBbox[1] > searchBbox[3] || featureBbox[3] < searchBbox[1]) {
                        return;
                    }
                    
                    try {
                        let candidatePoint = null;
                        let candidateDistance = Infinity;
                        
                        if (feature.geometry.type === 'Point') {
                            const coords = feature.geometry.coordinates;
                            candidateDistance = turf.distance(sitePoint, feature, { units: 'meters' });
                            candidatePoint = { lat: coords[1], lng: coords[0] };
                        } else if (feature.geometry.type === 'LineString') {
                            const nearestOnLine = turf.nearestPointOnLine(feature, sitePoint, { units: 'meters' });
                            candidateDistance = nearestOnLine.properties.dist;
                            candidatePoint = {
                                lat: nearestOnLine.geometry.coordinates[1],
                                lng: nearestOnLine.geometry.coordinates[0]
                            };
                        } else if (feature.geometry.type === 'MultiLineString') {
                            feature.geometry.coordinates.forEach(lineCoords => {
                                try {
                                    const line = turf.lineString(lineCoords);
                                    const nearestOnLine = turf.nearestPointOnLine(line, sitePoint, { units: 'meters' });
                                    if (nearestOnLine.properties.dist < candidateDistance) {
                                        candidateDistance = nearestOnLine.properties.dist;
                                        candidatePoint = {
                                            lat: nearestOnLine.geometry.coordinates[1],
                                            lng: nearestOnLine.geometry.coordinates[0]
                                        };
                                    }
                                } catch (e) {}
                            });
                        }
                        
                        if (!candidatePoint || candidateDistance > POC_MAX_DISTANCE_KM * 1000) return;
                        
                        // Check if this point is in a similar direction to any skipped point
                        // Use 45-degree threshold - the next cable should be in a different direction
                        const MIN_ANGLE_DIFFERENCE = 45; // degrees
                        const candidateBearing = turf.bearing(
                            turf.point([lng, lat]),
                            turf.point([candidatePoint.lng, candidatePoint.lat])
                        );
                        
                        const isSkipped = skippedPoints.some(sp => {
                            const skippedBearing = turf.bearing(
                                turf.point([lng, lat]),
                                turf.point([sp.lng, sp.lat])
                            );
                            // Calculate angular difference (handle wrap-around at 180/-180)
                            let angleDiff = Math.abs(candidateBearing - skippedBearing);
                            if (angleDiff > 180) angleDiff = 360 - angleDiff;
                            return angleDiff < MIN_ANGLE_DIFFERENCE;
                        });
                        
                        if (isSkipped) return;
                        
                        // Track if this is closer than current best for this key
                        if (!nearestMap[key] || candidateDistance < nearestMap[key].distance) {
                            nearestMap[key] = {
                                voltage,
                                type,
                                lat: candidatePoint.lat,
                                lng: candidatePoint.lng,
                                distance: candidateDistance,
                                layerConfig
                            };
                        }
                    } catch (e) {}
                });
            });
            
            // Convert map to results array in voltage order
            const voltageOrder = ['11kV', '33kV', '66kV', '132kV'];
            
            voltageOrder.forEach(voltage => {
                if (nearestMap[voltage]) {
                    results.push(nearestMap[voltage]);
                }
            });
            
            return results;
        }
        
        // Render single POC visuals (lines, markers, popup)
        function renderSinglePOCVisuals(results, latlng) {
            const clickLatLng = [latlng.lat, latlng.lng];
            
            results.forEach(r => {
                const color = VOLTAGE_POWER_RANGES[r.voltage]?.color || '#6b7280';
                const key = r.voltage;
                
                const line = L.polyline([
                    clickLatLng,
                    [r.lat, r.lng]
                ], {
                    color,
                    weight: 3,
                    dashArray: '8, 8',
                    opacity: 0.9
                }).addTo(map);
                
                singlePocLines[key] = line;
                
                const marker = L.circleMarker([r.lat, r.lng], {
                    radius: 7,
                    fillColor: color,
                    color: 'white',
                    weight: 2,
                    fillOpacity: 1
                }).addTo(map);
                
                singlePocMarkers[key] = marker;
            });
            
            // Check if any shuffling has occurred
            const hasShuffled = Object.keys(singlePocSkipped).length > 0;
            
            // Build popup content
            let html = `<div style="font-family: 'IBM Plex Mono', monospace; font-size: 12px;">`;
            html += '<strong>Nearest connections</strong><br>';
            html += '<div style="margin-top: 4px;">';
            
            results.forEach(r => {
                const color = VOLTAGE_POWER_RANGES[r.voltage]?.color || '#6b7280';
                html += `
                    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
                        <span style="width:10px;height:10px;border-radius:50%;background:${color};flex-shrink:0;"></span>
                        <span style="min-width:40px;">${r.voltage}</span>
                        <span style="font-size:11px;color:#6b7280;min-width:60px;">${r.type || ''}</span>
                        <span style="font-weight:600;">${formatDistance(r.distance)}</span>
                        <button onclick="shuffleSinglePOC('${r.voltage}')" 
                                title="Find next nearest"
                                style="margin-left:auto;padding:2px 6px;border-radius:3px;border:1px solid #e5e7eb;background:#f9fafb;font-size:10px;cursor:pointer;">
                            
                        </button>
                    </div>
                `;
            });
            
            html += '</div>';
            html += '<div style="display:flex;gap:6px;margin-top:8px;">';
            html += '<button onclick="addSiteFromSinglePOC()" style="flex:1;padding:4px 8px;border-radius:4px;border:none;background:#0f1112;color:white;font-size:11px;cursor:pointer;">Add Site</button>';
            
            if (hasShuffled) {
                html += '<button onclick="resetSinglePOC()" style="padding:4px 8px;border-radius:4px;border:1px solid #e5e7eb;background:#fff3cd;font-size:11px;cursor:pointer;">Reset</button>';
            }
            
            html += '<button onclick="clearSinglePOC()" style="padding:4px 8px;border-radius:4px;border:1px solid #e5e7eb;background:#f9fafb;font-size:11px;cursor:pointer;">Clear</button>';
            html += '</div>';
            html += '</div>';
            
            singlePocPopup = L.popup()
                .setLatLng(latlng)
                .setContent(html)
                .openOn(map);
        }
        
        // Shuffle to next nearest for a specific voltage-type
        function shuffleSinglePOC(voltage) {
            if (!singlePocClickLocation) return;
            
            const key = voltage;
            
            // Find current result for this voltage
            const currentResult = singlePocResults.find(r => r.voltage === voltage);
            if (!currentResult) return;
            
            // Add current point to skipped list
            if (!singlePocSkipped[key]) {
                singlePocSkipped[key] = [];
            }
            singlePocSkipped[key].push({ lat: currentResult.lat, lng: currentResult.lng });
            
            // Re-run search (not a reset, so skipped list is preserved)
            runSinglePOCAt({ lat: singlePocClickLocation.lat, lng: singlePocClickLocation.lng }, false);
        }
        
        // Reset to original results
        function resetSinglePOC() {
            if (!singlePocClickLocation) return;
            
            // Clear skipped and re-run
            singlePocSkipped = {};
            runSinglePOCAt({ lat: singlePocClickLocation.lat, lng: singlePocClickLocation.lng }, true);
        }
        
        // Clear only the visuals (not the state)
        function clearSinglePOCVisuals() {
            Object.values(singlePocLines).forEach(l => map.removeLayer(l));
            Object.values(singlePocMarkers).forEach(m => map.removeLayer(m));
            singlePocLines = {};
            singlePocMarkers = {};
            
            if (singlePocPopup) {
                map.closePopup(singlePocPopup);
                singlePocPopup = null;
            }
        }
        
        // ============== SITE FUNCTIONS ==============
        
        // Generate unique ID
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }
        
        // Load sites from localStorage
        function loadSitesFromStorage() {
            try {
                const stored = localStorage.getItem('poc-finder-sites');
                if (stored) {
                    sites = JSON.parse(stored);
                }
            } catch (e) {
                console.error('Failed to load sites from storage:', e);
                sites = [];
            }
        }
        
        // Save sites to localStorage
        function saveSitesToStorage() {
            try {
                localStorage.setItem('poc-finder-sites', JSON.stringify(sites));
            } catch (e) {
                console.error('Failed to save sites to storage:', e);
            }
        }
        
        // Create site marker
        function createSiteMarker(site) {
            const icon = L.divIcon({
                className: '',
                html: '<div class="site-marker-icon"></div>',
                iconSize: [24, 32],
                iconAnchor: [12, 32]  // Bottom center of pin
            });
            
            const marker = L.marker([site.lat, site.lng], { icon })
                .bindPopup(`<strong>${site.name}</strong><br>Click to view POCs`)
                .on('click', () => selectSite(site.id));
            
            return marker;
        }
        
        // Select a site
        function selectSite(siteId) {
            currentSiteId = siteId;
            const site = sites.find(s => s.id === siteId);
            
            if (!site) return;
            
            // Clear previous POC markers and lines
            clearPOCVisuals();
            
            // Create site marker if not exists
            if (!siteMarkers[siteId]) {
                siteMarkers[siteId] = createSiteMarker(site);
            }
            siteMarkers[siteId].addTo(map);
            
            // Pan to site
            map.setView([site.lat, site.lng], Math.max(map.getZoom(), 12));
            
            // Render side panel with site details
            renderSidePanel();
            
            // Draw POC markers and lines
            drawPOCVisuals(site);
        }
        
        // ============== OBSTACLE & CROSSING DETECTION ==============
        
        // Obstacle type colors
        const OBSTACLE_COLORS = {
            road: '#f59e0b',      // Orange
            railway: '#8b5cf6',   // Purple
            waterway: '#3b82f6',  // Blue
            builtup: 'rgba(168, 85, 247, 0.25)'  // Semi-transparent purple-red
        };
        
        // Tolerance in meters for near-miss detection
        const OBSTACLE_TOLERANCE_METERS = 3;
        
        // Helper: Check if two lines intersect or come within tolerance distance
        function linesIntersectOrNear(line1, line2, toleranceMeters) {
            // First check exact intersection
            const exactIntersections = turf.lineIntersect(line1, line2);
            if (exactIntersections.features.length > 0) {
                return { intersects: true, points: exactIntersections.features };
            }
            
            // Check for near-misses by sampling points along line1 and checking distance to line2
            const line1Length = turf.length(line1, { units: 'meters' });
            const numSamples = Math.max(10, Math.ceil(line1Length / 20)); // Sample every ~20m
            
            for (let i = 0; i <= numSamples; i++) {
                const fraction = i / numSamples;
                const pointOnLine1 = turf.along(line1, fraction * line1Length, { units: 'meters' });
                const nearestOnLine2 = turf.nearestPointOnLine(line2, pointOnLine1, { units: 'meters' });
                
                if (nearestOnLine2.properties.dist !== undefined && 
                    nearestOnLine2.properties.dist <= toleranceMeters) {
                    // Found a near-miss, return the nearest point as intersection
                    return { 
                        intersects: true, 
                        points: [{ geometry: { coordinates: nearestOnLine2.geometry.coordinates } }],
                        nearMiss: true
                    };
                }
            }
            
            // Also check points along line2 against line1 (for short segments)
            const line2Length = turf.length(line2, { units: 'meters' });
            const numSamples2 = Math.max(5, Math.ceil(line2Length / 30));
            
            for (let i = 0; i <= numSamples2; i++) {
                const fraction = i / numSamples2;
                const pointOnLine2 = turf.along(line2, fraction * line2Length, { units: 'meters' });
                const nearestOnLine1 = turf.nearestPointOnLine(line1, pointOnLine2, { units: 'meters' });
                
                if (nearestOnLine1.properties.dist !== undefined && 
                    nearestOnLine1.properties.dist <= toleranceMeters) {
                    return { 
                        intersects: true, 
                        points: [{ geometry: { coordinates: pointOnLine2.geometry.coordinates } }],
                        nearMiss: true
                    };
                }
            }
            
            return { intersects: false, points: [] };
        }
        
        // Helper: Check if a line intersects or passes through a polygon (with tolerance)
        function lineIntersectsPolygon(line, polygon, toleranceMeters) {
            const lineCoords = line.geometry.coordinates;
            const startPoint = turf.point(lineCoords[0]);
            const endPoint = turf.point(lineCoords[lineCoords.length - 1]);
            
            // Check if either endpoint is inside the polygon
            if (turf.booleanPointInPolygon(startPoint, polygon) || 
                turf.booleanPointInPolygon(endPoint, polygon)) {
                // Find centroid of polygon as the "crossing" point
                const centroid = turf.centroid(polygon);
                return { 
                    intersects: true, 
                    points: [{ geometry: { coordinates: centroid.geometry.coordinates } }],
                    containsEndpoint: true
                };
            }
            
            // Check for line intersection with polygon boundary
            const polygonLine = turf.polygonToLine(polygon);
            const intersection = turf.lineIntersect(line, polygonLine);
            if (intersection.features.length > 0) {
                return { intersects: true, points: intersection.features };
            }
            
            // Check if line crosses through polygon interior
            if (turf.booleanCrosses(line, polygon)) {
                const centroid = turf.centroid(polygon);
                return { 
                    intersects: true, 
                    points: [{ geometry: { coordinates: centroid.geometry.coordinates } }]
                };
            }
            
            // Check for near-misses (line passes very close to polygon)
            // Sample points along the line and check distance to polygon
            const lineLength = turf.length(line, { units: 'meters' });
            const numSamples = Math.max(10, Math.ceil(lineLength / 15));
            
            for (let i = 0; i <= numSamples; i++) {
                const fraction = i / numSamples;
                const pointOnLine = turf.along(line, fraction * lineLength, { units: 'meters' });
                
                // Check if point is inside or very close to polygon
                if (turf.booleanPointInPolygon(pointOnLine, polygon)) {
                    return { 
                        intersects: true, 
                        points: [{ geometry: { coordinates: pointOnLine.geometry.coordinates } }],
                        nearMiss: true
                    };
                }
                
                // Check distance to polygon boundary
                const nearestOnBoundary = turf.nearestPointOnLine(polygonLine, pointOnLine, { units: 'meters' });
                if (nearestOnBoundary.properties.dist !== undefined && 
                    nearestOnBoundary.properties.dist <= toleranceMeters) {
                    return { 
                        intersects: true, 
                        points: [{ geometry: { coordinates: nearestOnBoundary.geometry.coordinates } }],
                        nearMiss: true
                    };
                }
            }
            
            return { intersects: false, points: [] };
        }
        
        // Helper: Validate and sanitize coordinates
        function sanitizeCoords(coords) {
            return coords.filter(coord => {
                if (!Array.isArray(coord) || coord.length < 2) return false;
                const [lng, lat] = coord;
                return typeof lng === 'number' && typeof lat === 'number' &&
                       !isNaN(lng) && !isNaN(lat) &&
                       lng >= -180 && lng <= 180 && lat >= -90 && lat <= 90;
            });
        }
        
        // Detect all obstacles for a POC connection line
        async function detectObstacles(site, poc) {
            // Check cache first
            if (obstaclesCache[poc.id]) {
                return obstaclesCache[poc.id].crossings;
            }
            
            try {
                // Build path from waypoints or simple start->end
                let pathCoords;
                if (poc.waypoints && poc.waypoints.length > 0) {
                    pathCoords = [
                        [site.lng, site.lat],
                        ...poc.waypoints.map(wp => [wp.lng, wp.lat]),
                        [poc.lng, poc.lat]
                    ];
                } else {
                    pathCoords = [
                        [site.lng, site.lat],
                        [poc.lng, poc.lat]
                    ];
                }
                
                // Sanitize coordinates
                pathCoords = sanitizeCoords(pathCoords);
                if (pathCoords.length < 2) {
                    console.warn('Invalid path coordinates for obstacle detection');
                    obstaclesCache[poc.id] = { crossings: [], builtupAreas: [], fetched: true };
                    return [];
                }
                
                // Create the connection line from all waypoints
                const connectionLine = turf.lineString(pathCoords);
                
                // Calculate bounding box with padding
                const bbox = turf.bbox(connectionLine);
                const padding = 0.005;  // ~500m padding
                const paddedBbox = [
                    bbox[0] - padding,  // minLng
                    bbox[1] - padding,  // minLat
                    bbox[2] + padding,  // maxLng
                    bbox[3] + padding   // maxLat
                ];
                
                // Build Overpass API query for roads, railways, waterways, and buildings
                // Include all drivable surfaces: roads, tracks, service roads, etc.
                // Only exclude pedestrian-only paths: footway, cycleway, bridleway, steps, pedestrian
                const query = `
                    [out:json][timeout:15];
                    (
                        way["highway"]["highway"!~"footway|cycleway|bridleway|steps|pedestrian|corridor"]
                            (${paddedBbox[1]},${paddedBbox[0]},${paddedBbox[3]},${paddedBbox[2]});
                        way["railway"="rail"]
                            (${paddedBbox[1]},${paddedBbox[0]},${paddedBbox[3]},${paddedBbox[2]});
                        way["waterway"~"river|canal"]
                            (${paddedBbox[1]},${paddedBbox[0]},${paddedBbox[3]},${paddedBbox[2]});
                        way["building"]
                            (${paddedBbox[1]},${paddedBbox[0]},${paddedBbox[3]},${paddedBbox[2]});
                    );
                    out geom;
                `;
                
                // Fetch from Overpass API
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                
                if (!response.ok) {
                    throw new Error(`Overpass API error: ${response.status}`);
                }
                
                const data = await response.json();
                const crossings = [];
                const builtupAreas = [];  // Store polygons for overlay
                
                // Track already-detected obstacles to avoid duplicates
                const detectedObstacles = new Set();
                
                // Process each element
                data.elements.forEach(element => {
                    if (!element.geometry && !element.members) return;
                    
                    const tags = element.tags || {};
                    
                    // Determine obstacle type
                    let obstacleType = null;
                    let obstacleName = 'Unknown';
                    
                    if (tags.highway) {
                        obstacleType = 'road';
                        obstacleName = tags.name || `${tags.highway} road`;
                    } else if (tags.railway) {
                        obstacleType = 'railway';
                        obstacleName = tags.name || 'Railway';
                    } else if (tags.waterway) {
                        obstacleType = 'waterway';
                        obstacleName = tags.name || `${tags.waterway}`;
                    } else if (tags.building) {
                        obstacleType = 'building';
                        obstacleName = tags.name || 'Building';
                    }
                    
                    if (!obstacleType) return;
                    
                    // Handle ways (lines or polygons)
                    if (element.type === 'way' && element.geometry) {
                        let coords = element.geometry.map(pt => [pt.lon, pt.lat]);
                        coords = sanitizeCoords(coords);
                        if (coords.length < 2) return;
                        
                        // Create unique key to avoid duplicates
                        const obstacleKey = `${element.id}-${obstacleType}`;
                        if (detectedObstacles.has(obstacleKey)) return;
                        
                        if (obstacleType === 'building') {
                            // For buildings, check if line passes through polygon
                            if (coords.length >= 3) {
                                // Close the polygon if needed
                                const polyCoords = [...coords];
                                if (polyCoords[0][0] !== polyCoords[polyCoords.length-1][0] || 
                                    polyCoords[0][1] !== polyCoords[polyCoords.length-1][1]) {
                                    polyCoords.push(polyCoords[0]);
                                }
                                
                                // Need at least 4 points for a valid polygon (3 vertices + closing point)
                                if (polyCoords.length < 4) return;
                                
                                try {
                                    const polygon = turf.polygon([polyCoords]);
                                    
                                    // Use robust intersection check
                                    const result = lineIntersectsPolygon(connectionLine, polygon, OBSTACLE_TOLERANCE_METERS);
                                    
                                    if (result.intersects) {
                                        detectedObstacles.add(obstacleKey);
                                        
                                        // Store polygon for overlay
                                        builtupAreas.push({
                                            coords: polyCoords,
                                            name: obstacleName,
                                            type: tags.building
                                        });
                                        
                                        // Add crossing point
                                        if (result.points.length > 0) {
                                            const pt = result.points[0].geometry.coordinates;
                                            crossings.push({
                                                lat: pt[1],
                                                lng: pt[0],
                                                obstacleName: obstacleName,
                                                obstacleType: obstacleType,
                                                subType: tags.building,
                                                nearMiss: result.nearMiss || false
                                            });
                                        }
                                    }
                                } catch (e) {
                                    // Invalid polygon geometry - log and skip
                                    console.warn(`Invalid building polygon (element ${element.id}):`, e.message);
                                }
                            }
                        } else {
                            // For linear features (roads, railways, waterways)
                            try {
                                const featureLine = turf.lineString(coords);
                                
                                // Use robust intersection check with tolerance
                                const result = linesIntersectOrNear(connectionLine, featureLine, OBSTACLE_TOLERANCE_METERS);
                                
                                if (result.intersects) {
                                    detectedObstacles.add(obstacleKey);
                                    
                                    result.points.forEach(intersection => {
                                        const pt = intersection.geometry.coordinates;
                                        crossings.push({
                                            lat: pt[1],
                                            lng: pt[0],
                                            obstacleName: obstacleName,
                                            obstacleType: obstacleType,
                                            subType: tags.highway || tags.railway || tags.waterway,
                                            nearMiss: result.nearMiss || false
                                        });
                                    });
                                }
                            } catch (e) {
                                // Invalid line geometry - log and skip
                                console.warn(`Invalid linear feature (element ${element.id}):`, e.message);
                            }
                        }
                    }
                });
                
                // Cache the results
                obstaclesCache[poc.id] = {
                    crossings: crossings,
                    builtupAreas: builtupAreas,
                    fetched: true
                };
                
                return crossings;
                
            } catch (error) {
                console.error('Obstacle detection failed:', error);
                // Cache empty result to avoid repeated failed requests
                obstaclesCache[poc.id] = {
                    crossings: [],
                    builtupAreas: [],
                    fetched: true,
                    error: true
                };
                return [];
            }
        }
        
        
        // ============== END OBSTACLE & CROSSING DETECTION ==============
        
        // Clear all POC markers and lines from map
        function clearPOCVisuals() {
            Object.values(pocMarkers).forEach(m => map.removeLayer(m));
            Object.values(pocLines).forEach(l => map.removeLayer(l));
            // Clear waypoint markers
            Object.values(pocWaypointMarkers).forEach(markers => {
                markers.forEach(m => map.removeLayer(m));
            });
            // Clear road crossing markers
            Object.values(obstacleCrossingMarkers).forEach(markers => {
                markers.forEach(m => map.removeLayer(m));
            });
            // Clear obstacle overlays
            Object.values(obstacleOverlays).forEach(overlays => {
                overlays.forEach(o => map.removeLayer(o));
            });
            pocMarkers = {};
            pocLines = {};
            pocWaypointMarkers = {};
            obstacleCrossingMarkers = {};
            obstacleOverlays = {};
        }
        
        // Clear obstacles for a specific POC
        function clearPOCObstacles(pocId) {
            // Clear road crossing markers for this POC
            if (obstacleCrossingMarkers[pocId]) {
                obstacleCrossingMarkers[pocId].forEach(m => map.removeLayer(m));
                delete obstacleCrossingMarkers[pocId];
            }
            // Clear obstacle overlays for this POC
            if (obstacleOverlays[pocId]) {
                obstacleOverlays[pocId].forEach(o => map.removeLayer(o));
                delete obstacleOverlays[pocId];
            }
            // Clear cache for this POC
            delete obstaclesCache[pocId];
        }
        
        // Storage for POC waypoint markers
        let pocWaypointMarkers = {};
        
        // Calculate total path distance from waypoints
        function calculatePathDistance(site, poc) {
            const points = [
                [site.lng, site.lat],
                ...(poc.waypoints || []).map(wp => [wp.lng, wp.lat]),
                [poc.lng, poc.lat]
            ];
            
            let totalDistance = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const from = turf.point(points[i]);
                const to = turf.point(points[i + 1]);
                totalDistance += turf.distance(from, to, { units: 'meters' });
            }
            return totalDistance;
        }
        
        // Get full path including waypoints
        function getFullPath(site, poc) {
            return [
                [site.lat, site.lng],
                ...(poc.waypoints || []).map(wp => [wp.lat, wp.lng]),
                [poc.lat, poc.lng]
            ];
        }
        
        // Rebuild line and waypoint markers for a POC
        function rebuildPOCLine(site, poc) {
            const color = poc.color || '#6b7280';
            const line = pocLines[poc.id];
            
            if (!line) return;
            
            // Update line path
            line.setLatLngs(getFullPath(site, poc));
            
            // Clear existing waypoint markers
            if (pocWaypointMarkers[poc.id]) {
                pocWaypointMarkers[poc.id].forEach(m => map.removeLayer(m));
            }
            pocWaypointMarkers[poc.id] = [];
            
            // Create waypoint markers
            (poc.waypoints || []).forEach((wp, index) => {
                const wpMarker = L.marker([wp.lat, wp.lng], {
                    draggable: true,
                    icon: L.divIcon({
                        className: '',
                        html: `<div style="
                            width: 12px;
                            height: 12px;
                            border-radius: 50%;
                            background: white;
                            border: 2px solid ${color};
                            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                            cursor: grab;
                        "></div>`,
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    })
                }).addTo(map);
                
                // Drag to move waypoint
                wpMarker.on('drag', function(e) {
                    poc.waypoints[index] = { lat: e.target.getLatLng().lat, lng: e.target.getLatLng().lng };
                    line.setLatLngs(getFullPath(site, poc));
                });
                
                wpMarker.on('dragend', function() {
                    // Recalculate distance and obstacles
                    poc.distance = calculatePathDistance(site, poc);
                    recalculatePOCObstacles(site, poc);
                });
                
                // Double-click to remove waypoint
                wpMarker.on('dblclick', function(e) {
                    L.DomEvent.stopPropagation(e);
                    poc.waypoints.splice(index, 1);
                    poc.distance = calculatePathDistance(site, poc);
                    rebuildPOCLine(site, poc);
                    recalculatePOCObstacles(site, poc);
                });
                
                wpMarker.bindTooltip('Drag to move, double-click to remove', { direction: 'top', offset: [0, -5] });
                
                pocWaypointMarkers[poc.id].push(wpMarker);
            });
        }
        
        // Recalculate obstacles after path change
        function recalculatePOCObstacles(site, poc) {
            clearPOCObstacles(poc.id);
            
            detectObstacles(site, poc).then(crossings => {
                const cacheData = obstaclesCache[poc.id];
                
                saveSitesToStorage();
                
                // Draw obstacles
                drawObstacleVisualsForPOC(poc, cacheData, crossings);
                
                // Update side panel
                renderSidePanel();
            });
        }
        
        // Draw obstacle visuals for a POC
        function drawObstacleVisualsForPOC(poc, cacheData, crossings) {
            // Draw built-up area overlays
            if (cacheData?.builtupAreas?.length > 0) {
                obstacleOverlays[poc.id] = [];
                
                cacheData.builtupAreas.forEach(area => {
                    const polygon = L.polygon(
                        area.coords.map(c => [c[1], c[0]]),
                        {
                            color: 'rgba(168, 85, 247, 0.6)',
                            fillColor: 'rgba(168, 85, 247, 0.25)',
                            fillOpacity: 0.25,
                            weight: 1
                        }
                    ).addTo(map);
                    
                    polygon.bindPopup(`
                        <strong>Building</strong><br>
                        ${area.name}<br>
                        <em>${area.type}</em>
                    `);
                    
                    obstacleOverlays[poc.id].push(polygon);
                });
            }
            
            // Draw crossing markers
            if (crossings.length > 0) {
                obstacleCrossingMarkers[poc.id] = [];
                
                crossings.forEach(crossing => {
                    const crossingMarker = L.marker([crossing.lat, crossing.lng], {
                        icon: L.divIcon({
                            className: '',
                            html: `<div class="obstacle-crossing-marker"></div>`,
                            iconSize: [8, 8],
                            iconAnchor: [4, 4]
                        })
                    }).addTo(map);
                    
                    const typeLabel = crossing.obstacleType === 'road' ? 'Road' :
                                     crossing.obstacleType === 'railway' ? 'Railway' :
                                     crossing.obstacleType === 'waterway' ? 'Waterway' :
                                     crossing.obstacleType === 'building' ? 'Building' : 'Obstacle';
                    
                    crossingMarker.bindPopup(`
                        <strong>${typeLabel} Crossing</strong><br>
                        ${crossing.obstacleName}<br>
                        <em>${crossing.subType}</em>
                    `);
                    
                    obstacleCrossingMarkers[poc.id].push(crossingMarker);
                });
            }
        }
        
        // Draw POC markers and connection lines
        function drawPOCVisuals(site) {
            site.pocs.forEach(poc => {
                const color = poc.color || '#6b7280';
                
                // Initialize waypoints array if not present
                if (!poc.waypoints) {
                    poc.waypoints = [];
                }
                
                // Connection line with all waypoints
                const line = L.polyline(getFullPath(site, poc), {
                    color: color,
                    weight: 3,
                    dashArray: '8, 8',
                    opacity: 0.8
                }).addTo(map);
                pocLines[poc.id] = line;
                
                // Click on line to add waypoint
                line.on('click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    
                    // Find which segment was clicked and insert waypoint there
                    const clickPoint = [e.latlng.lng, e.latlng.lat];
                    const path = getFullPath(site, poc);
                    
                    let bestSegmentIndex = 0;
                    let minDistance = Infinity;
                    
                    for (let i = 0; i < path.length - 1; i++) {
                        const segmentLine = turf.lineString([
                            [path[i][1], path[i][0]],
                            [path[i+1][1], path[i+1][0]]
                        ]);
                        const nearest = turf.nearestPointOnLine(segmentLine, turf.point(clickPoint));
                        if (nearest.properties.dist < minDistance) {
                            minDistance = nearest.properties.dist;
                            bestSegmentIndex = i;
                        }
                    }
                    
                    // Insert new waypoint at the clicked position
                    const newWaypoint = { lat: e.latlng.lat, lng: e.latlng.lng };
                    poc.waypoints.splice(bestSegmentIndex, 0, newWaypoint);
                    
                    // Recalculate distance
                    poc.distance = calculatePathDistance(site, poc);
                    
                    // Rebuild line and markers
                    rebuildPOCLine(site, poc);
                    recalculatePOCObstacles(site, poc);
                });
                
                // Add tooltip to line
                line.bindTooltip('Click to add waypoint', { sticky: true });
                
                // POC endpoint marker - draggable
                const marker = L.marker([poc.lat, poc.lng], {
                    draggable: true,
                    icon: L.divIcon({
                        className: '',
                        html: `<div style="
                            width: 20px;
                            height: 20px;
                            border-radius: 50%;
                            background: ${color};
                            border: 3px solid white;
                            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                            cursor: grab;
                        "></div>`,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    })
                }).addTo(map);
                
                // Update popup content function
                const updatePopup = () => {
                    marker.bindPopup(`
                        <strong>${poc.voltage}</strong><br>
                        ${poc.type}<br>
                        ${formatDistance(poc.distance)}<br>
                        <em>${poc.powerMin} - ${poc.powerMax} MVA</em><br>
                        <small style="color:#6b7280;">Drag endpoint to adjust</small>
                    `);
                };
                updatePopup();
                pocMarkers[poc.id] = marker;
                
                // Drag event handlers for endpoint
                marker.on('drag', function(e) {
                    const newLatLng = e.target.getLatLng();
                    poc.lat = newLatLng.lat;
                    poc.lng = newLatLng.lng;
                    line.setLatLngs(getFullPath(site, poc));
                });
                
                marker.on('dragend', function(e) {
                    // Snap to nearest cable of the same voltage
                    const draggedLatLng = e.target.getLatLng();
                    const snappedPoint = findNearestCablePoint(draggedLatLng.lat, draggedLatLng.lng, poc.voltage, poc.layerName);
                    
                    if (snappedPoint) {
                        poc.lat = snappedPoint.lat;
                        poc.lng = snappedPoint.lng;
                        marker.setLatLng([snappedPoint.lat, snappedPoint.lng]);
                        line.setLatLngs(getFullPath(site, poc));
                    }
                    
                    poc.distance = calculatePathDistance(site, poc);
                    clearPOCObstacles(poc.id);
                    
                    detectObstacles(site, poc).then(crossings => {
                        const cacheData = obstaclesCache[poc.id];
                        
                        saveSitesToStorage();
                        
                        drawObstacleVisualsForPOC(poc, cacheData, crossings);
                        updatePopup();
                        renderSidePanel();
                    });
                });
                
                // Create waypoint markers
                rebuildPOCLine(site, poc);
                
                // Detect and draw obstacles
                detectObstacles(site, poc).then(crossings => {
                    const cacheData = obstaclesCache[poc.id];
                    
                    saveSitesToStorage();
                    
                    // Draw obstacles using helper function
                    drawObstacleVisualsForPOC(poc, cacheData, crossings);
                    
                    // Update side panel to show crossing info
                    renderSidePanel();
                });
            });
        }
        
        // Update side panel visibility based on whether sites exist
        function updateSidePanelVisibility() {
            const panel = document.getElementById('side-panel');
            if (sites.length > 0) {
                panel.classList.add('visible');
            } else {
                panel.classList.remove('visible');
            }
        }
        
        // Deselect current site and show site list
        function deselectSite() {
            currentSiteId = null;
            clearPOCVisuals();
            renderSidePanel();
        }
        
        // Site list filtering & sorting state
        let siteFilterText = '';
        let siteSortMode = 'name_asc'; // 'name_asc' | 'poc_desc' | 'voltage_desc'
        
        function handleSiteSearchChange(value) {
            siteFilterText = value || '';
            renderSidePanel();
        }
        
        function handleSiteSortChange(value) {
            siteSortMode = value || 'name_asc';
            renderSidePanel();
        }
        
        // Render side panel content - shows site list or site details
        function renderSidePanel() {
            const content = document.getElementById('side-panel-content');
            const header = document.querySelector('.side-panel-header h3');
            const closeBtn = document.querySelector('.side-panel-close');
            const site = sites.find(s => s.id === currentSiteId);
            
            updateSidePanelVisibility();
            
            if (!site) {
                // Show site list
                header.textContent = 'Sites';
                closeBtn.style.display = 'none';
                
                if (sites.length === 0) {
                    content.innerHTML = '<div class="poc-empty">No sites added yet</div>';
                    return;
                }
                
                // Apply search filter
                const filter = siteFilterText.trim().toLowerCase();
                let filteredSites = sites.filter(s => {
                    if (!filter) return true;
                    const nameMatch = s.name.toLowerCase().includes(filter);
                    const coordMatch = `${s.lat.toFixed(4)},${s.lng.toFixed(4)}`.includes(filter);
                    const voltageMatch = (s.pocs || []).some(p => p.voltage.toLowerCase().includes(filter));
                    return nameMatch || coordMatch || voltageMatch;
                });
                
                // Sort sites
                filteredSites = filteredSites.slice().sort((a, b) => {
                    if (siteSortMode === 'poc_desc') {
                        return (b.pocs?.length || 0) - (a.pocs?.length || 0);
                    }
                    if (siteSortMode === 'voltage_desc') {
                        const va = new Set((a.pocs || []).map(p => p.voltage)).size;
                        const vb = new Set((b.pocs || []).map(p => p.voltage)).size;
                        return vb - va;
                    }
                    // name_asc default
                    return a.name.localeCompare(b.name);
                });
                
                const siteListHTML = filteredSites.map(s => {
                    const voltages = [...new Set(s.pocs.map(p => p.voltage))];
                    const voltageTagsHTML = voltages.map(v => {
                        const color = VOLTAGE_POWER_RANGES[v]?.color || '#6b7280';
                        return `<span class="site-list-voltage-tag" style="background:${color}">${v}</span>`;
                    }).join('');
                    
                    return `
                        <div class="site-list-item" onclick="selectSite('${s.id}')">
                            <div class="site-list-item-name">${s.name}</div>
                            <div class="site-list-item-meta">
                                <span>${s.pocs.length} POC${s.pocs.length !== 1 ? 's' : ''}</span>
                                <span>${s.lat.toFixed(4)}, ${s.lng.toFixed(4)}</span>
                            </div>
                            ${voltageTagsHTML ? `<div class="site-list-item-voltages">${voltageTagsHTML}</div>` : ''}
                        </div>
                    `;
                }).join('');
                
                const controlsHTML = `
                    <div class="site-list-controls">
                        <div class="site-list-search">
                            <span style="font-size:11px;color:var(--color-muted);"></span>
                            <input
                                type="text"
                                id="site-search-input"
                                placeholder="Search by name, voltage, or coords"
                                value="${siteFilterText.replace(/"/g, '&quot;')}"
                                oninput="handleSiteSearchChange(this.value)"
                            />
                        </div>
                        <div class="site-list-sort">
                            <span>Sort by</span>
                            <select id="site-sort-select" onchange="handleSiteSortChange(this.value)">
                                <option value="name_asc"${siteSortMode === 'name_asc' ? ' selected' : ''}>Name (AZ)</option>
                                <option value="poc_desc"${siteSortMode === 'poc_desc' ? ' selected' : ''}>POC count</option>
                                <option value="voltage_desc"${siteSortMode === 'voltage_desc' ? ' selected' : ''}>Voltage diversity</option>
                            </select>
                        </div>
                    </div>
                `;
                
                content.innerHTML = controlsHTML + (siteListHTML || '<div class="poc-empty">No sites match your filters.</div>');
                return;
            }
            
            // Show site details
            header.textContent = 'Site Details';
            closeBtn.style.display = 'block';
            
            // POC cards
            const pocCardsHTML = site.pocs.map(poc => {
                const color = poc.color || '#6b7280';
                
                // Get obstacle crossings from cache
                const crossingData = obstaclesCache[poc.id];
                const crossings = crossingData?.crossings || [];
                const builtupAreas = crossingData?.builtupAreas || [];
                const isLoading = !crossingData?.fetched;
                
                // Group crossings by type
                const roadCrossings = crossings.filter(c => c.obstacleType === 'road');
                const railwayCrossings = crossings.filter(c => c.obstacleType === 'railway');
                const waterwayCrossings = crossings.filter(c => c.obstacleType === 'waterway');
                const builtupCrossings = crossings.filter(c => c.obstacleType === 'builtup');
                
                const hasObstacles = crossings.length > 0 || builtupAreas.length > 0;
                
                // Build detailed obstacle breakdown HTML
                let obstacleHTML = '';
                if (isLoading) {
                    obstacleHTML = '<div class="poc-crossings loading">Checking for obstacles...</div>';
                } else if (hasObstacles) {
                    // Build detailed list of individual obstacles
                    let obstacleDetailItems = [];
                    
                    // Group obstacles by type and show names
                    if (roadCrossings.length > 0) {
                        const roadNames = [...new Set(roadCrossings.map(c => c.obstacleName || 'Unnamed road'))];
                        roadNames.forEach(name => {
                            const count = roadCrossings.filter(c => (c.obstacleName || 'Unnamed road') === name).length;
                            const displayName = name.length > 30 ? name.substring(0, 30) + '...' : name;
                            obstacleDetailItems.push(`
                                <div class="obstacle-detail-item road">
                                    <span class="obstacle-type-icon" style="background:#f59e0b"></span>
                                    <span class="obstacle-detail-name">${displayName}</span>
                                    ${count > 1 ? `<span class="obstacle-detail-count">${count}</span>` : ''}
                                </div>
                            `);
                        });
                    }
                    
                    if (railwayCrossings.length > 0) {
                        const railNames = [...new Set(railwayCrossings.map(c => c.obstacleName || 'Railway'))];
                        railNames.forEach(name => {
                            const count = railwayCrossings.filter(c => (c.obstacleName || 'Railway') === name).length;
                            const displayName = name.length > 30 ? name.substring(0, 30) + '...' : name;
                            obstacleDetailItems.push(`
                                <div class="obstacle-detail-item railway">
                                    <span class="obstacle-type-icon" style="background:#8b5cf6"></span>
                                    <span class="obstacle-detail-name">${displayName}</span>
                                    ${count > 1 ? `<span class="obstacle-detail-count">${count}</span>` : ''}
                                </div>
                            `);
                        });
                    }
                    
                    if (waterwayCrossings.length > 0) {
                        const waterNames = [...new Set(waterwayCrossings.map(c => c.obstacleName || 'Waterway'))];
                        waterNames.forEach(name => {
                            const count = waterwayCrossings.filter(c => (c.obstacleName || 'Waterway') === name).length;
                            const displayName = name.length > 30 ? name.substring(0, 30) + '...' : name;
                            obstacleDetailItems.push(`
                                <div class="obstacle-detail-item waterway">
                                    <span class="obstacle-type-icon" style="background:#3b82f6"></span>
                                    <span class="obstacle-detail-name">${displayName}</span>
                                    ${count > 1 ? `<span class="obstacle-detail-count">${count}</span>` : ''}
                                </div>
                            `);
                        });
                    }
                    
                    if (builtupAreas.length > 0) {
                        const buildingNames = [...new Set(builtupAreas.map(b => b.name || 'Building'))];
                        buildingNames.forEach(name => {
                            const count = builtupAreas.filter(b => (b.name || 'Building') === name).length;
                            const displayName = name.length > 30 ? name.substring(0, 30) + '...' : name;
                            obstacleDetailItems.push(`
                                <div class="obstacle-detail-item building">
                                    <span class="obstacle-type-icon" style="background:#a855f7"></span>
                                    <span class="obstacle-detail-name">${displayName}</span>
                                    ${count > 1 ? `<span class="obstacle-detail-count">${count}</span>` : ''}
                                </div>
                            `);
                        });
                    }
                    
                    // Summary counts
                    const summaryItems = [];
                    if (roadCrossings.length > 0) summaryItems.push(`${roadCrossings.length} road${roadCrossings.length > 1 ? 's' : ''}`);
                    if (railwayCrossings.length > 0) summaryItems.push(`${railwayCrossings.length} railway${railwayCrossings.length > 1 ? 's' : ''}`);
                    if (waterwayCrossings.length > 0) summaryItems.push(`${waterwayCrossings.length} waterway${waterwayCrossings.length > 1 ? 's' : ''}`);
                    if (builtupAreas.length > 0) summaryItems.push(`${builtupAreas.length} building${builtupAreas.length > 1 ? 's' : ''}`);
                    
                    obstacleHTML = `
                        <div class="poc-obstacles warning">
                            <div class="obstacle-header">
                                <span class="obstacle-warning-icon"></span>
                                <span class="obstacle-summary">${summaryItems.join(', ')}</span>
                            </div>
                            <div class="obstacle-detail-list">${obstacleDetailItems.join('')}</div>
                        </div>
                    `;
                } else if (crossingData?.fetched) {
                    obstacleHTML = '<div class="poc-obstacles clear"><span class="obstacle-clear-icon"></span> Route clear  no obstacles detected</div>';
                }
                
                const isFocused = focusedPocId === poc.id;
                
                return `
                    <div class="poc-card${hasObstacles ? ' has-crossings' : ''}${isFocused ? ' focused' : ''}" onclick="focusPOC('${poc.id}')">
                        <div class="poc-card-header">
                            <div class="poc-voltage-badge" style="background: ${color}">${poc.voltage}</div>
                            <div class="poc-card-info">
                                <div class="poc-power-range">${poc.powerMin}  ${poc.powerMax} MVA</div>
                                <div class="poc-card-distance">${formatDistance(poc.distance)}${poc.routedDistance ? ` / ${formatDistance(poc.routedDistance)} routed` : ''}</div>
                                <div class="poc-card-type">${poc.type}${poc.isCustom ? ' <span class="poc-custom-badge">Custom</span>' : ''}</div>
                            </div>
                        </div>
                        ${obstacleHTML}
                        <div class="poc-card-actions">
                            <button class="poc-action-btn reject" onclick="event.stopPropagation(); removePOC('${poc.id}')">Remove</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Parcel info display
            let parcelInfoHTML = '';
            if (site.parcelId || site.parcelArea) {
                const areaHectares = site.parcelArea ? (site.parcelArea / 10000).toFixed(2) : 'N/A';
                parcelInfoHTML = `
                    <div class="site-info-parcel" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.1); font-size: 11px; color: #6b7280;">
                        <div><strong>Parcel ID:</strong> ${site.parcelId || 'N/A'}</div>
                        <div><strong>Parcel Area:</strong> ${areaHectares} ha</div>
                    </div>
                `;
            }
            
            content.innerHTML = `
                <div class="site-info">
                    <div class="site-info-name-row">
                        <div class="site-info-name">${site.name}</div>
                        <button class="site-rename-btn" onclick="renameSite('${site.id}')" title="Rename site">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                        </button>
                    </div>
                    <div class="site-info-coords">${site.lat.toFixed(5)}, ${site.lng.toFixed(5)}</div>
                    ${parcelInfoHTML}
                    <div class="site-actions">
                        <button class="site-action-btn" onclick="rerunPOCDiscovery()">Re-scan</button>
                        <button class="site-action-btn" onclick="exportSiteReport('${site.id}')">Export PDF</button>
                        <button class="site-action-btn danger" onclick="deleteSite('${site.id}')">Delete</button>
                    </div>
                </div>
                
                <div class="poc-section-header">
                    <div class="poc-section-title">Connection Options</div>
                </div>
                
                ${focusedPocId ? `
                    <button class="show-all-btn" onclick="exitFocusMode()">
                         Show All Layers
                    </button>
                ` : ''}
                
                ${site.pocs.length > 0 ? pocCardsHTML : '<div class="poc-empty">No connections found within 30km.</div>'}
            `;
        }
        
        // Remove a POC from the current site
        function removePOC(pocId) {
            const site = sites.find(s => s.id === currentSiteId);
            if (!site) return;
            
            // Exit focus mode if removing the focused POC
            if (focusedPocId === pocId) {
                exitFocusMode();
            }
            
            site.pocs = site.pocs.filter(p => p.id !== pocId);
            saveSitesToStorage();
            
            // Redraw visuals and panel
            clearPOCVisuals();
            drawPOCVisuals(site);
            renderSidePanel();
        }
        
        // Focus on a specific POC - hide all other layers and show only the connected feature
        function focusPOC(pocId) {
            const site = sites.find(s => s.id === currentSiteId);
            if (!site) return;
            
            const poc = site.pocs.find(p => p.id === pocId);
            if (!poc) return;
            
            // Exit any existing focus mode first
            if (focusedPocId) {
                exitFocusMode();
            }
            
            focusedPocId = pocId;
            
            // Hide all cable and substation layers
            LAYERS.forEach(layerConfig => {
                const layer = layerGroups[layerConfig.name];
                if (layer && map.hasLayer(layer)) {
                    map.removeLayer(layer);
                }
            });
            
            Object.entries(substationLayerGroups).forEach(([name, layerGroup]) => {
                if (layerGroup && map.hasLayer(layerGroup)) {
                    map.removeLayer(layerGroup);
                }
            });
            
            // Find and highlight the specific feature this POC connects to
            const geoJSON = rawGeoJSONData[poc.layerName];
            if (geoJSON && geoJSON.features) {
                // Find the nearest feature to the POC point
                const pocPoint = turf.point([poc.lng, poc.lat]);
                let nearestFeature = null;
                let nearestDist = Infinity;
                
                geoJSON.features.forEach(feature => {
                    if (!feature.geometry) return;
                    
                    try {
                        let dist;
                        if (feature.geometry.type === 'Point') {
                            dist = turf.distance(pocPoint, feature, { units: 'meters' });
                        } else if (feature.geometry.type === 'LineString') {
                            const nearest = turf.nearestPointOnLine(feature, pocPoint, { units: 'meters' });
                            dist = nearest.properties.dist;
                        } else if (feature.geometry.type === 'MultiLineString') {
                            feature.geometry.coordinates.forEach(coords => {
                                const line = turf.lineString(coords);
                                const nearest = turf.nearestPointOnLine(line, pocPoint, { units: 'meters' });
                                if (nearest.properties.dist < dist || dist === undefined) {
                                    dist = nearest.properties.dist;
                                }
                            });
                        }
                        
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestFeature = feature;
                        }
                    } catch (e) {
                        // Skip invalid features
                    }
                });
                
                // Create highlight layer for the nearest feature
                if (nearestFeature) {
                    const layerConfig = getLayerConfig(poc.layerName);
                    const color = layerConfig?.color || poc.color || '#3b82f6';
                    
                    if (nearestFeature.geometry.type === 'Point') {
                        // Substation - create a highlighted marker
                        const coords = nearestFeature.geometry.coordinates;
                        focusHighlightLayer = L.circleMarker([coords[1], coords[0]], {
                            radius: 12,
                            fillColor: color,
                            color: 'white',
                            weight: 3,
                            fillOpacity: 0.9
                        }).addTo(map);
                    } else {
                        // Cable - create a highlighted line
                        focusHighlightLayer = L.geoJSON(nearestFeature, {
                            style: {
                                color: color,
                                weight: 5,
                                opacity: 1
                            }
                        }).addTo(map);
                    }
                }
            }
            
            // Zoom to fit site and POC
            const bounds = L.latLngBounds([
                [site.lat, site.lng],
                [poc.lat, poc.lng]
            ]);
            map.fitBounds(bounds, { padding: [80, 80], maxZoom: 16 });
            
            // Re-render panel to show focused state
            renderSidePanel();
        }
        
        // Exit focus mode and restore all layers
        function exitFocusMode() {
            if (!focusedPocId) return;
            
            focusedPocId = null;
            
            // Remove highlight layer
            if (focusHighlightLayer) {
                map.removeLayer(focusHighlightLayer);
                focusHighlightLayer = null;
            }
            
            // Restore all layers based on current filter
            updateLayerVisibility();
            
            // Re-render panel
            renderSidePanel();
        }
        
        // Delete a site
        function deleteSite(siteId) {
            if (!confirm('Delete this site and all its POCs?')) return;
            
            // Remove marker
            if (siteMarkers[siteId]) {
                map.removeLayer(siteMarkers[siteId]);
                delete siteMarkers[siteId];
            }
            
            // Remove from array
            sites = sites.filter(s => s.id !== siteId);
            saveSitesToStorage();
            
            // Deselect if this was the current site
            if (currentSiteId === siteId) {
                currentSiteId = null;
                clearPOCVisuals();
            }
            
            // Update panel (will show list or hide if no sites)
            renderSidePanel();
        }
        
        // Re-run POC discovery for current site
        function rerunPOCDiscovery() {
            if (currentSiteId) {
                discoverPOCs(currentSiteId);
            }
        }
        
        // Export site report as PDF
        async function exportSiteReport(siteId) {
            const site = sites.find(s => s.id === siteId);
            if (!site) return;
            
            // Show loading state
            const exportBtn = document.querySelector('.site-action-btn:nth-child(2)');
            const originalText = exportBtn.textContent;
            exportBtn.textContent = 'Generating...';
            exportBtn.disabled = true;
            
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                
                // Colors
                const primaryColor = [15, 17, 18];
                const mutedColor = [102, 109, 112];
                
                // Header
                doc.setFontSize(24);
                doc.setTextColor(...primaryColor);
                doc.text('Site Connection Report', 20, 25);
                
                doc.setFontSize(10);
                doc.setTextColor(...mutedColor);
                doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 33);
                
                // Site Info
                doc.setFontSize(14);
                doc.setTextColor(...primaryColor);
                doc.text('Site Information', 20, 48);
                
                doc.setFontSize(11);
                doc.text(`Name: ${site.name}`, 25, 58);
                doc.text(`Coordinates: ${site.lat.toFixed(6)}, ${site.lng.toFixed(6)}`, 25, 66);
                doc.text(`Total POCs: ${site.pocs.length}`, 25, 74);
                
                // POC Table Header
                doc.setFontSize(14);
                doc.text('Connection Options', 20, 92);
                
                // Table
                const tableStartY = 100;
                const colWidths = [30, 30, 40, 70];
                const headers = ['Voltage', 'Type', 'Distance', 'Obstacles'];
                
                // Draw header row
                doc.setFillColor(235, 239, 240);
                doc.rect(20, tableStartY - 6, 170, 10, 'F');
                
                doc.setFontSize(9);
                doc.setTextColor(...primaryColor);
                let xPos = 22;
                headers.forEach((header, i) => {
                    doc.text(header, xPos, tableStartY);
                    xPos += colWidths[i];
                });
                
                // Draw data rows
                doc.setFontSize(9);
                let yPos = tableStartY + 12;
                
                site.pocs.forEach((poc, index) => {
                    // Alternate row backgrounds
                    if (index % 2 === 0) {
                        doc.setFillColor(250, 250, 250);
                        doc.rect(20, yPos - 5, 170, 10, 'F');
                    }
                    
                    xPos = 22;
                    
                    // Voltage
                    doc.setTextColor(...primaryColor);
                    doc.text(poc.voltage, xPos, yPos);
                    xPos += colWidths[0];
                    
                    // Type
                    doc.text(poc.type, xPos, yPos);
                    xPos += colWidths[1];
                    
                    // Distance
                    doc.text(formatDistance(poc.distance), xPos, yPos);
                    xPos += colWidths[2];
                    
                    // Obstacles
                    const obstacleDataPdf = obstaclesCache[poc.id];
                    let obstacleText = 'N/A';
                    if (obstacleDataPdf?.fetched) {
                        const count = (obstacleDataPdf.crossings?.length || 0) + (obstacleDataPdf.builtupAreas?.length || 0);
                        obstacleText = count > 0 ? `${count} detected` : 'None';
                    }
                    doc.text(obstacleText, xPos, yPos);
                    
                    yPos += 10;
                    
                    // Add new page if needed
                    if (yPos > 270) {
                        doc.addPage();
                        yPos = 20;
                    }
                });
                
                // Summary section
                yPos += 10;
                if (yPos > 240) {
                    doc.addPage();
                    yPos = 20;
                }
                
                doc.setFontSize(14);
                doc.setTextColor(...primaryColor);
                doc.text('Summary', 20, yPos);
                yPos += 12;
                
                // Find best option
                const sortedByDistance = [...site.pocs].sort((a, b) => a.distance - b.distance);
                
                doc.setFontSize(10);
                if (sortedByDistance.length > 0) {
                    const closest = sortedByDistance[0];
                    doc.text(`Closest connection: ${closest.voltage} ${closest.type} at ${formatDistance(closest.distance)}`, 25, yPos);
                    yPos += 8;
                }
                
                // Recommendations
                yPos += 8;
                doc.setFontSize(12);
                doc.text('Recommendations:', 25, yPos);
                yPos += 10;
                
                doc.setFontSize(10);
                doc.setTextColor(...mutedColor);
                
                const recommendations = [];
                
                // Check for high voltage options
                const highVoltage = site.pocs.filter(p => p.voltage === '132kV' || p.voltage === '66kV');
                if (highVoltage.length > 0) {
                    recommendations.push('High voltage connections (66kV/132kV) available - suitable for large projects.');
                }
                
                // Check for obstacle-free options
                const obstacleFree = site.pocs.filter(p => {
                    const data = obstaclesCache[p.id];
                    return data?.fetched && (data.crossings?.length || 0) + (data.builtupAreas?.length || 0) === 0;
                });
                if (obstacleFree.length > 0) {
                    recommendations.push(`${obstacleFree.length} connection(s) with no detected obstacles - may offer simpler routing.`);
                }
                
                // Check distances
                const closeOptions = site.pocs.filter(p => p.distance < 1000);
                if (closeOptions.length > 0) {
                    recommendations.push(`${closeOptions.length} connection(s) within 1km - good proximity.`);
                }
                
                if (recommendations.length === 0) {
                    recommendations.push('Consider all options carefully based on project requirements.');
                }
                
                recommendations.forEach(rec => {
                    doc.text(` ${rec}`, 28, yPos, { maxWidth: 160 });
                    yPos += 10;
                });
                
                // Footer
                doc.setFontSize(8);
                doc.setTextColor(...mutedColor);
                doc.text('This report is for preliminary assessment only. Actual costs and feasibility should be confirmed with the DNO.', 20, 285);
                
                // Save the PDF
                doc.save(`${site.name.replace(/[^a-zA-Z0-9]/g, '_')}_connection_report.pdf`);
                
            } catch (error) {
                console.error('Error generating PDF:', error);
                alert('Error generating PDF. Please try again.');
            } finally {
                exportBtn.textContent = originalText;
                exportBtn.disabled = false;
            }
        }
        
        // ============== POC DISCOVERY ALGORITHM ==============
        
        // Extract voltage from layer name
        function extractVoltage(layerName) {
            if (layerName.includes('11kV')) return '11kV';
            if (layerName.includes('33kV')) return '33kV';
            if (layerName.includes('66kV')) return '66kV';
            if (layerName.includes('132kV')) return '132kV';
            return null;
        }
        
        // Find nearest connection for each voltage level
        function findNearestPerVoltage(siteLat, siteLng, maxDistanceKm = 30) {
            const sitePoint = turf.point([siteLng, siteLat]);
            // Only search layers that match current MVA filter
            const visibleLayerNames = getVisibleLayerNames();
            
            // Track nearest per voltage
            const nearestPerVoltage = {};
            const nearest11kVSubstation = { result: null };
            
            const searchBuffer = turf.buffer(sitePoint, maxDistanceKm, { units: 'kilometers' });
            const searchBbox = turf.bbox(searchBuffer);
            
            visibleLayerNames.forEach(layerName => {
                const geoJSON = rawGeoJSONData[layerName];
                if (!geoJSON || !geoJSON.features) return;
                
                const layerConfig = getLayerConfig(layerName);
                if (!layerConfig) return;
                
                const voltage = extractVoltage(layerName);
                if (!voltage) return;
                
                const isSubstation = layerConfig.isSubstation || layerConfig.isGSP;
                
                geoJSON.features.forEach((feature) => {
                    if (!feature.geometry) return;
                    
                    // Quick bounding box check
                    const featureBbox = turf.bbox(feature);
                    if (featureBbox[0] > searchBbox[2] || featureBbox[2] < searchBbox[0] ||
                        featureBbox[1] > searchBbox[3] || featureBbox[3] < searchBbox[1]) {
                        return;
                    }
                    
                    try {
                        let candidatePoint = null;
                        let candidateDistance = Infinity;
                        
                        // Handle Point geometries (substations)
                        if (feature.geometry.type === 'Point') {
                            const coords = feature.geometry.coordinates;
                            candidateDistance = turf.distance(sitePoint, feature, { units: 'meters' });
                            if (candidateDistance <= maxDistanceKm * 1000) {
                                candidatePoint = { lat: coords[1], lng: coords[0] };
                            }
                        }
                        // Handle LineString
                        else if (feature.geometry.type === 'LineString') {
                            const nearest = turf.nearestPointOnLine(feature, sitePoint, { units: 'meters' });
                            candidateDistance = nearest.properties.dist;
                            if (candidateDistance <= maxDistanceKm * 1000) {
                                const coords = nearest.geometry.coordinates;
                                candidatePoint = { lat: coords[1], lng: coords[0] };
                            }
                        }
                        // Handle MultiLineString
                        else if (feature.geometry.type === 'MultiLineString') {
                            feature.geometry.coordinates.forEach(lineCoords => {
                                const line = turf.lineString(lineCoords);
                                const nearest = turf.nearestPointOnLine(line, sitePoint, { units: 'meters' });
                                if (nearest.properties.dist < candidateDistance) {
                                    candidateDistance = nearest.properties.dist;
                                    const coords = nearest.geometry.coordinates;
                                    candidatePoint = { lat: coords[1], lng: coords[0] };
                                }
                            });
                        }
                        
                        // Update tracking
                        if (candidatePoint && candidateDistance <= maxDistanceKm * 1000) {
                            const result = {
                                lat: candidatePoint.lat,
                                lng: candidatePoint.lng,
                                distance: candidateDistance,
                                layerConfig: layerConfig,
                                type: isSubstation ? 'Substation' : 'Cable'
                            };
                            
                            // For 11kV, track substation separately (no 11kV cables)
                            if (voltage === '11kV') {
                                if (isSubstation) {
                                    if (!nearest11kVSubstation.result || candidateDistance < nearest11kVSubstation.result.distance) {
                                        nearest11kVSubstation.result = result;
                                    }
                                }
                            } else {
                                // For other voltages, just track nearest regardless of type
                                if (!nearestPerVoltage[voltage] || candidateDistance < nearestPerVoltage[voltage].distance) {
                                    nearestPerVoltage[voltage] = result;
                                }
                            }
                        }
                    } catch (e) {
                        // Skip invalid geometries
                    }
                });
            });
            
            // Return results including 11kV substation
            return {
                nearestPerVoltage,
                nearest11kVSubstation: nearest11kVSubstation.result
            };
        }
        
        // Discover POCs for a site - find nearest connection per voltage level
        function discoverPOCs(siteId) {
            const site = sites.find(s => s.id === siteId);
            if (!site) return;
            
            // Show loading state
            const content = document.getElementById('side-panel-content');
            content.innerHTML = `
                <div class="poc-loading">
                    <div class="poc-loading-spinner"></div>
                    <div>Discovering points of connection...</div>
                </div>
            `;
            
            // Use setTimeout to allow UI to update
            setTimeout(() => {
                const { nearestPerVoltage, nearest11kVSubstation } = findNearestPerVoltage(site.lat, site.lng);
                const discoveredPOCs = [];
                const powerRange11kV = VOLTAGE_POWER_RANGES['11kV'];
                
                // Add 11kV Substation if found
                if (nearest11kVSubstation) {
                    discoveredPOCs.push({
                        id: generateId(),
                        voltage: '11kV',
                        lat: nearest11kVSubstation.lat,
                        lng: nearest11kVSubstation.lng,
                        distance: nearest11kVSubstation.distance,
                        type: 'Substation',
                        layerName: nearest11kVSubstation.layerConfig.name,
                        powerMin: powerRange11kV.min,
                        powerMax: powerRange11kV.max,
                        color: powerRange11kV.color,
                        status: 'pending'
                    });
                }
                
                // Add other voltages (33kV, 66kV, 132kV)
                const otherVoltages = ['33kV', '66kV', '132kV'];
                
                otherVoltages.forEach(voltage => {
                    const nearest = nearestPerVoltage[voltage];
                    if (nearest) {
                        const powerRange = VOLTAGE_POWER_RANGES[voltage];
                        discoveredPOCs.push({
                            id: generateId(),
                            voltage: voltage,
                            lat: nearest.lat,
                            lng: nearest.lng,
                            distance: nearest.distance,
                            type: nearest.type,
                            layerName: nearest.layerConfig.name,
                            powerMin: powerRange.min,
                            powerMax: powerRange.max,
                            color: powerRange.color,
                            status: 'pending'
                        });
                    }
                });
                
                // Update site
                site.pocs = discoveredPOCs;
                saveSitesToStorage();
                
                // Redraw
                clearPOCVisuals();
                drawPOCVisuals(site);
                renderSidePanel();
            }, 100);
        }
        
        // ============== END SITE & POC FINDER FUNCTIONS ==============

        // Finish loading and show map
        function finishLoading() {
            // Add base map layer control only (no overlays)
            // Track previous base map for keyboard shortcuts
            let previousBaseMap = currentBaseMap;
            let isSatelliteShortcutActive = false;
            let isColourShortcutActive = false;
            let isLightShortcutActive = false;
            
            // Keyboard shortcuts: hold 's' for satellite, 'c' for colour, 'l' for light
            document.addEventListener('keydown', function(e) {
                // Ignore if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                // Satellite shortcut (s key)
                if (e.key === 's' || e.key === 'S') {
                    if (!isSatelliteShortcutActive && !isColourShortcutActive && !isLightShortcutActive) {
                        isSatelliteShortcutActive = true;
                        previousBaseMap = currentBaseMap;
                        
                        // Switch to satellite
                        Object.keys(baseMaps).forEach(key => {
                            if (map.hasLayer(baseMaps[key])) {
                                map.removeLayer(baseMaps[key]);
                            }
                        });
                        baseMaps['Satellite'].addTo(map);
                        currentBaseMap = 'Satellite';
                        updateMapLayerSelection('Satellite');
                    }
                }
                
                // Colour shortcut (c key)
                if (e.key === 'c' || e.key === 'C') {
                    if (!isColourShortcutActive && !isSatelliteShortcutActive && !isLightShortcutActive) {
                        isColourShortcutActive = true;
                        previousBaseMap = currentBaseMap;
                        
                        // Switch to colour
                        Object.keys(baseMaps).forEach(key => {
                            if (map.hasLayer(baseMaps[key])) {
                                map.removeLayer(baseMaps[key]);
                            }
                        });
                        baseMaps['Colour'].addTo(map);
                        currentBaseMap = 'Colour';
                        updateMapLayerSelection('Colour');
                    }
                }
                
                // Light shortcut (l key)
                if (e.key === 'l' || e.key === 'L') {
                    if (!isLightShortcutActive && !isSatelliteShortcutActive && !isColourShortcutActive) {
                        isLightShortcutActive = true;
                        previousBaseMap = currentBaseMap;
                        
                        // Switch to light
                        Object.keys(baseMaps).forEach(key => {
                            if (map.hasLayer(baseMaps[key])) {
                                map.removeLayer(baseMaps[key]);
                            }
                        });
                        baseMaps['Light'].addTo(map);
                        currentBaseMap = 'Light';
                        updateMapLayerSelection('Light');
                    }
                }
            });
            
            document.addEventListener('keyup', function(e) {
                // Satellite shortcut release
                if ((e.key === 's' || e.key === 'S') && isSatelliteShortcutActive) {
                    isSatelliteShortcutActive = false;
                    
                    // Revert to previous base map
                    if (map.hasLayer(baseMaps['Satellite'])) {
                        map.removeLayer(baseMaps['Satellite']);
                    }
                    baseMaps[previousBaseMap].addTo(map);
                    currentBaseMap = previousBaseMap;
                    updateMapLayerSelection(previousBaseMap);
                }
                
                // Colour shortcut release
                if ((e.key === 'c' || e.key === 'C') && isColourShortcutActive) {
                    isColourShortcutActive = false;
                    
                    // Revert to previous base map
                    if (map.hasLayer(baseMaps['Colour'])) {
                        map.removeLayer(baseMaps['Colour']);
                    }
                    baseMaps[previousBaseMap].addTo(map);
                    currentBaseMap = previousBaseMap;
                    updateMapLayerSelection(previousBaseMap);
                }
                
                // Light shortcut release
                if ((e.key === 'l' || e.key === 'L') && isLightShortcutActive) {
                    isLightShortcutActive = false;
                    
                    // Revert to previous base map
                    if (map.hasLayer(baseMaps['Light'])) {
                        map.removeLayer(baseMaps['Light']);
                    }
                    baseMaps[previousBaseMap].addTo(map);
                    currentBaseMap = previousBaseMap;
                    updateMapLayerSelection(previousBaseMap);
                }
            });
            
            // Add filter panel (left side, above POC button)
            const filterPanel = L.control({ position: 'topleft' });
            filterPanel.onAdd = function() {
                const div = L.DomUtil.create('div', 'filter-panel');
                
                // Build cable layer indicators HTML
                let cableIndicatorsHTML = LAYERS.map(l => {
                    const id = l.name.replace(/[^a-zA-Z0-9]/g, '');
                    return `
                        <div class="layer-indicator" id="indicator-${id}">
                            <span class="layer-dot" style="background: ${l.color}"></span>
                            <span>${l.name}</span>
                            <span class="layer-mva">${l.mvaMin}-${l.mvaMax}</span>
                        </div>
                    `;
                }).join('');
                
                // Build substation layer indicators HTML
                let substationIndicatorsHTML = SUBSTATION_LAYERS.map(l => {
                    const id = l.name.replace(/[^a-zA-Z0-9]/g, '');
                    return `
                        <div class="layer-indicator" id="indicator-${id}">
                            <span class="layer-dot" style="background: ${l.color}; width: ${Math.min(l.radius, 10)}px; height: ${Math.min(l.radius, 10)}px;"></span>
                            <span>${l.name}</span>
                            <span class="layer-mva">${l.mvaMin}-${l.mvaMax}</span>
                        </div>
                    `;
                }).join('');
                
                div.innerHTML = `
                    <h4>Project Size</h4>
                    <p class="subtitle">Filter networks by connection capacity (MVA)</p>
                    
                    <div class="mva-display">
                        <div class="mva-value">
                            <div class="label">Min</div>
                            <div class="number" id="mva-min">${formatMVA(filterMin)}</div>
                        </div>
                        <div class="mva-separator">to</div>
                        <div class="mva-value">
                            <div class="label">Max</div>
                            <div class="number" id="mva-max">${formatMVA(filterMax)}</div>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <div id="mva-slider"></div>
                    </div>
                    
                    <div class="map-layers">
                        <div class="map-layers-title">Map View</div>
                        <div class="map-layer-option ${currentBaseMap === 'Light' ? 'selected' : ''}" data-layer="Light">
                            <span>Light</span>
                            <span class="shortcut">Hold L</span>
                        </div>
                        <div class="map-layer-option ${currentBaseMap === 'Colour' ? 'selected' : ''}" data-layer="Colour">
                            <span>Colour</span>
                            <span class="shortcut">Hold C</span>
                        </div>
                        <div class="map-layer-option ${currentBaseMap === 'Satellite' ? 'selected' : ''}" data-layer="Satellite">
                            <span>Satellite</span>
                            <span class="shortcut">Hold S</span>
                        </div>
                    </div>
                    
                    <div class="active-layers">
                        <div class="active-layers-title">Cables</div>
                        ${cableIndicatorsHTML}
                    </div>
                    
                    <div class="active-layers" style="margin-top: 12px;">
                        <div class="active-layers-title">Substations</div>
                        ${substationIndicatorsHTML}
                    </div>
                `;
                
                // Prevent map interactions when using the slider
                L.DomEvent.disableClickPropagation(div);
                L.DomEvent.disableScrollPropagation(div);
                
                return div;
            };
            filterPanel.addTo(map);
            
            // Function to update selected map layer in UI
            function updateMapLayerSelection(selectedLayer) {
                const options = document.querySelectorAll('.map-layer-option');
                if (options.length === 0) return; // Panel not yet rendered
                options.forEach(option => {
                    if (option.dataset.layer === selectedLayer) {
                        option.classList.add('selected');
                    } else {
                        option.classList.remove('selected');
                    }
                });
            }
            
            // Add click handlers for map layer options
            setTimeout(() => {
                const mapLayerOptions = document.querySelectorAll('.map-layer-option');
                mapLayerOptions.forEach(option => {
                    option.addEventListener('click', function() {
                        const layerName = this.dataset.layer;
                        if (layerName !== currentBaseMap && !isSatelliteShortcutActive && !isColourShortcutActive && !isLightShortcutActive) {
                            // Remove all base layers
                            Object.keys(baseMaps).forEach(key => {
                                if (map.hasLayer(baseMaps[key])) {
                                    map.removeLayer(baseMaps[key]);
                                }
                            });
                            // Add selected layer
                            baseMaps[layerName].addTo(map);
                            currentBaseMap = layerName;
                            previousBaseMap = layerName;
                            updateMapLayerSelection(layerName);
                        }
                    });
                });
            }, 100);
            
            // Initialize the slider after the panel is added to DOM
            setTimeout(() => {
                const slider = document.getElementById('mva-slider');
                
                noUiSlider.create(slider, {
                    start: [filterMin, filterMax],
                    connect: true,
                    range: {
                        'min': [0.5],
                        '20%': [2],
                        '40%': [10],
                        '60%': [30],
                        '80%': [60],
                        'max': [100]
                    },
                    tooltips: false,
                    pips: {
                        mode: 'values',
                        values: [0.5, 5, 20, 50, 100],
                        density: 10,
                        format: {
                            to: (v) => v >= 1 ? v.toFixed(0) : v.toFixed(1)
                        }
                    }
                });
                
                // Customize handle styling after creation
                const handles = slider.querySelectorAll('.noUi-handle');
                handles.forEach(handle => {
                    handle.style.width = '8px';
                    handle.style.height = '8px';
                    handle.style.borderRadius = '2px';
                    // Background set via CSS for theme support
                    handle.style.border = 'none';
                    handle.style.boxShadow = 'none';
                    handle.style.top = '0px';
                    handle.style.right = '-4px';
                    handle.style.boxSizing = 'border-box';
                });
                
                slider.noUiSlider.on('update', function(values) {
                    filterMin = parseFloat(values[0]);
                    filterMax = parseFloat(values[1]);
                    updateMVADisplay();
                    updateLayerVisibility();
                });
                
                // Apply initial filter
                updateLayerVisibility();
            }, 100);
            
            // Load saved sites from localStorage and show markers
            loadSitesFromStorage();
            sites.forEach(site => {
                siteMarkers[site.id] = createSiteMarker(site);
                siteMarkers[site.id].addTo(map);
            });
            
            // Show side panel with site list if sites exist
            renderSidePanel();
            
            // Fit to bounds if we have data
            if (allBounds && allBounds.isValid()) {
                map.fitBounds(allBounds, { padding: [20, 20] });
            }
            
            // Default one-off POC on map click (lightweight alternative to POC mode)
            map.on('click', handleSinglePOCClick);
            
            // Add zoom handler to update substation marker sizes
            map.on('zoomend', updateSubstationSizes);
            
            // Initial size update
            updateSubstationSizes();
            
            // Hide loading overlay
            document.getElementById('loading').classList.add('hidden');
        }

        // Load all layers
        async function init() {
            // Load cable layers and substations in parallel
            await Promise.all([
                ...LAYERS.map(loadLayer),
                loadAllSubstations()
            ]);
        }

        // Start loading
        init();
    </script>
</body>
</html>
