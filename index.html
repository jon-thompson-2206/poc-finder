<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NPG Power Lines Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin=""/>
    
    <!-- noUiSlider CSS -->
    <link rel="stylesheet" href="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.css">
    
    <!-- IBM Plex Mono font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --color-dark: #0f1112;
            --color-light: #f6f6f5;
            --color-muted: #666d70;
            --color-border: #ebeff0;
        }
        
* {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'IBM Plex Mono', monospace;
        }
        
        #map {
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }
        
        /* Override Leaflet's default grab cursors to use crosshair for measurement mode */
        #map .leaflet-container {
            cursor: crosshair;
        }
        
        #map .leaflet-grab {
            cursor: crosshair;
        }
        
        #map .leaflet-dragging .leaflet-grab {
            cursor: grabbing;
        }
        
        /* Interactive elements (cables, parcels) show pointer on hover */
        #map .leaflet-interactive {
            cursor: pointer !important;
        }
        
        /* Custom Legend */
        .legend {
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
            line-height: 1.6;
            min-width: 140px;
        }
        
        .legend h4 {
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #1f2937;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 6px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #374151;
            padding: 2px 0;
        }
        
        .legend-color {
            width: 24px;
            height: 4px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        /* Zoom controls - 25% smaller */
        .leaflet-control-zoom a {
            width: 23px !important;
            height: 23px !important;
            line-height: 23px !important;
            font-size: 14px !important;
        }
        
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.3s ease;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: #22c55e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: white;
            margin-top: 16px;
            font-size: 14px;
        }
        
        .loading-progress {
            color: rgba(255, 255, 255, 0.7);
            margin-top: 8px;
            font-size: 12px;
        }
        
        /* Popup styling */
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
        }
        
        .popup-content {
            font-size: 13px;
            line-height: 1.5;
        }
        
        .popup-content strong {
            color: #1f2937;
        }
        
        .popup-content .voltage-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: white;
            margin-bottom: 6px;
        }
        
        /* Filter Panel */
        .filter-panel {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 12px 14px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(15, 17, 18, 0.12);
            border: 1px solid var(--color-border);
            width: 260px;
            font-family: 'IBM Plex Mono', monospace;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }
        
        .filter-panel h4 {
            margin: 0 0 4px 0;
            font-size: 13px;
            font-weight: 600;
            color: var(--color-dark);
        }
        
        .filter-panel .subtitle {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 10px;
        }
        
        .mva-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 6px 10px;
            background: #f3f4f6;
            border-radius: 6px;
        }
        
        .mva-value {
            text-align: center;
        }
        
        .mva-value .label {
            font-size: 9px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .mva-value .number {
            font-size: 15px;
            font-weight: 700;
            color: #1f2937;
        }
        
        .mva-separator {
            font-size: 12px;
            color: #9ca3af;
            font-weight: 500;
        }
        
        .filter-section {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid #e5e7eb;
        }
        
        .slider-container {
            padding: 6px 6px 0 6px;
            margin-bottom: 42px;
        }
        
        /* noUiSlider custom styling */
        .noUi-target {
            background: #e5e7eb;
            border: none;
            box-shadow: none;
            height: 12px;
            border-radius: 4px;
        }
        
        .noUi-connect {
            background: var(--color-muted);
            border-radius: 4px;
        }
        
        .noUi-handle {
            width: 12px !important;
            height: 12px !important;
            border-radius: 2px !important;
            background: var(--color-dark) !important;
            border: none !important;
            box-shadow: none !important;
            cursor: grab;
            top: 0px !important;
            right: -4px !important;
            box-sizing: border-box !important;
        }
        
        .noUi-handle:before,
        .noUi-handle:after {
            display: none;
        }
        
        .noUi-handle:focus {
            outline: none;
        }
        
        .noUi-handle:active {
            cursor: grabbing;
        }
        
        /* Active layers list */
        .active-layers {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid #e5e7eb;
        }
        
        .active-layers-title {
            font-size: 10px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .layer-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 0;
            font-size: 11px;
            color: #374151;
            transition: opacity 0.2s ease;
        }
        
        .layer-indicator.hidden {
            opacity: 0.35;
            text-decoration: line-through;
        }
        
        .layer-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        /* Map layer options */
        .map-layers {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid #e5e7eb;
        }
        
        .map-layers-title {
            font-size: 10px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .map-layer-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 5px 10px;
            margin-bottom: 2px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
            color: #374151;
            background: transparent;
            border: 1px solid transparent;
        }
        
        .map-layer-option:hover {
            background: #f3f4f6;
        }
        
        .map-layer-option.selected {
            background: #e0e7ff;
            border-color: #6366f1;
            color: #1e40af;
            font-weight: 500;
        }
        
        .map-layer-option .shortcut {
            font-size: 11px;
            color: #9ca3af;
            font-weight: normal;
        }
        
        .map-layer-option.selected .shortcut {
            color: #6366f1;
        }
        
        .layer-mva {
            margin-left: auto;
            font-size: 11px;
            color: #9ca3af;
        }
        
        .layer-toggle {
            cursor: pointer;
            user-select: none;
        }
        
        .layer-toggle:hover {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            margin: 0 -4px;
            padding: 4px 4px;
        }
        
        .layer-toggle-check {
            font-size: 12px;
            color: #22c55e;
            transition: opacity 0.2s ease;
        }
        
        /* Slider pips */
        .noUi-pips {
            color: #9ca3af;
            font-size: 10px;
        }
        
        .noUi-pips-horizontal {
            padding: 8px 0 0 0;
            height: auto;
        }
        
        .noUi-marker-horizontal.noUi-marker-large {
            height: 8px;
        }
        
        .noUi-value {
            padding-top: 2px;
        }
        
        /* Location Search */
        .location-search {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e7eb;
            position: relative;
        }
        
        .location-search-title {
            font-size: 10px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        .location-search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .location-search-icon {
            position: absolute;
            left: 8px;
            width: 14px;
            height: 14px;
            color: #9ca3af;
            pointer-events: none;
        }
        
        .location-search-input {
            width: 100%;
            padding: 7px 30px 7px 28px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.7);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: var(--color-dark);
            transition: all 0.2s ease;
        }
        
        .location-search-input:focus {
            outline: none;
            border-color: var(--color-muted);
            box-shadow: 0 0 0 2px rgba(102, 109, 112, 0.15);
            background: rgba(255, 255, 255, 0.95);
        }
        
        .location-search-input::placeholder {
            color: #9ca3af;
        }
        
        .location-search-clear {
            position: absolute;
            right: 8px;
            width: 20px;
            height: 20px;
            border: none;
            background: #e5e7eb;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            color: #6b7280;
            font-size: 12px;
            line-height: 1;
            padding: 0;
            transition: all 0.2s ease;
        }
        
        .location-search-clear:hover {
            background: #d1d5db;
            color: #374151;
        }
        
        .location-search-clear.visible {
            display: flex;
        }
        
        .location-search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            margin-top: 4px;
            max-height: 240px;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(15, 17, 18, 0.15);
            z-index: 1000;
            display: none;
        }
        
        .location-search-results.visible {
            display: block;
        }
        
        .location-search-result {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            transition: background 0.15s ease;
        }
        
        .location-search-result:last-child {
            border-bottom: none;
        }
        
        .location-search-result:hover {
            background: #f3f4f6;
        }
        
        .location-search-result-name {
            font-size: 12px;
            font-weight: 500;
            color: var(--color-dark);
            margin-bottom: 2px;
        }
        
        .location-search-result-address {
            font-size: 10px;
            color: #6b7280;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .location-search-loading {
            padding: 16px;
            text-align: center;
            color: #6b7280;
            font-size: 11px;
        }
        
        .location-search-loading::after {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #e5e7eb;
            border-top-color: #6b7280;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 8px;
            vertical-align: middle;
        }
        
        .location-search-no-results {
            padding: 16px;
            text-align: center;
            color: #6b7280;
            font-size: 11px;
        }
        
        /* POC Mode Styles */
        .poc-mode-active {
            cursor: crosshair !important;
        }
        
        .poc-mode-active .leaflet-interactive {
            cursor: crosshair !important;
        }
        
        .poc-button {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(15, 17, 18, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
            transition: all 0.2s ease;
        }
        
        .poc-button:hover {
            background: #f9fafb;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .poc-button.active {
            background: #22c55e;
            color: white;
        }
        
        .poc-button.active:hover {
            background: #16a34a;
        }
        
        .poc-button svg {
            width: 18px;
            height: 18px;
        }
        
        /* Distance tooltip that follows cursor */
        .poc-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(15, 17, 18, 0.92);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: var(--color-light);
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            transform: translate(-50%, -100%);
            margin-top: -16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.15s ease;
            min-width: 160px;
        }
        
        .poc-tooltip.visible {
            opacity: 1;
        }
        
        .poc-tooltip .poc-tooltip-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .poc-tooltip .poc-tooltip-row:last-child {
            border-bottom: none;
        }
        
        .poc-tooltip .poc-voltage-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .poc-tooltip .poc-voltage-label {
            font-size: 12px;
            font-weight: 600;
            min-width: 45px;
        }
        
        .poc-tooltip .poc-distance-val {
            font-size: 13px;
            font-weight: 700;
            margin-left: auto;
        }
        
        .poc-tooltip.no-connection {
            background: rgba(239, 68, 68, 0.95);
        }
        
        .poc-tooltip .no-connection-msg {
            font-size: 12px;
            text-align: center;
        }
        
        /* ============== SITE & POC PANEL STYLES ============== */
        
        /* Add Site button */
        .add-site-button {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(15, 17, 18, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
            transition: all 0.2s ease;
            margin-top: 8px;
        }
        
        .add-site-button:hover {
            background: #f9fafb;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .add-site-button.active {
            background: #3b82f6;
            color: white;
        }
        
        .add-site-button.active:hover {
            background: #2563eb;
        }
        
        .add-site-button svg {
            width: 18px;
            height: 18px;
        }
        
        /* Site mode cursor */
        .add-site-mode-active {
            cursor: crosshair !important;
        }
        
        .add-site-mode-active .leaflet-interactive {
            cursor: crosshair !important;
        }
        
        /* Add POC mode cursor */
        .add-poc-mode-active {
            cursor: pointer !important;
        }
        
        .add-poc-mode-active .leaflet-interactive {
            cursor: pointer !important;
        }
        
        /* Obstacle Mode button */
        .obstacle-mode-button {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(15, 17, 18, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
            transition: all 0.2s ease;
            margin-top: 8px;
        }
        
        .obstacle-mode-button:hover {
            background: #f9fafb;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .obstacle-mode-button.active {
            background: #a855f7;
            color: white;
        }
        
        .obstacle-mode-button.active:hover {
            background: #9333ea;
        }
        
        .obstacle-mode-button svg {
            width: 18px;
            height: 18px;
        }
        
        /* Heatmap button */
        .heatmap-button {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(15, 17, 18, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
            transition: all 0.2s ease;
            margin-top: 8px;
        }
        
        .heatmap-button:hover {
            background: #f9fafb;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .heatmap-button.active {
            background: #f97316;
            color: white;
        }
        
        .heatmap-button.active:hover {
            background: #ea580c;
        }
        
        .heatmap-button svg {
            width: 18px;
            height: 18px;
        }
        
        /* Find Location button */
        .find-location-button {
            background: rgba(246, 246, 245, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(15, 17, 18, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
            transition: all 0.2s ease;
            margin-top: 8px;
        }
        
        .find-location-button:hover {
            background: #f9fafb;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .find-location-button.active {
            background: #eab308;
            color: white;
        }
        
        .find-location-button.active:hover {
            background: #ca8a04;
        }
        
        .find-location-button svg {
            width: 18px;
            height: 18px;
        }
        
        /* Find Location instruction */
        .find-location-instruction {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(234, 179, 8, 0.95);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        /* Location recommendation marker */
        .location-recommendation-marker {
            width: 28px;
            height: 28px;
            background: #eab308;
            border: 3px solid white;
            border-radius: 50%;
            color: white;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* Location results panel */
        .location-results-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(246, 246, 245, 0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 0;
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .location-results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--color-border);
            font-weight: 600;
            font-size: 12px;
        }
        
        .location-results-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--color-muted);
            padding: 0;
            line-height: 1;
        }
        
        .location-results-close:hover {
            color: var(--color-dark);
        }
        
        .location-results-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .location-result-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .location-result-item:hover {
            background: rgba(0, 0, 0, 0.03);
        }
        
        .location-result-item:last-child {
            border-bottom: none;
        }
        
        .location-result-rank {
            width: 24px;
            height: 24px;
            background: #eab308;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            flex-shrink: 0;
        }
        
        .location-result-info {
            flex: 1;
        }
        
        .location-result-score {
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
        }
        
        .location-result-detail {
            font-size: 10px;
            color: var(--color-muted);
        }
        
        .location-use-btn {
            padding: 4px 10px;
            background: var(--color-dark);
            color: var(--color-light);
            border: none;
            border-radius: 4px;
            font-size: 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .location-use-btn:hover {
            background: var(--color-muted);
        }
        
        /* Obstacle mode cursor */
        .obstacle-mode-active {
            cursor: crosshair !important;
        }
        
        .obstacle-mode-active .leaflet-interactive {
            cursor: crosshair !important;
        }
        
        /* Obstacle selection rectangle */
        .obstacle-selection-rect {
            fill: rgba(168, 85, 247, 0.2);
            stroke: #a855f7;
            stroke-width: 2;
            stroke-dasharray: 6 4;
        }
        
        /* Obstacle results panel */
        .obstacle-results {
            background: rgba(246, 246, 245, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 12px;
            margin-top: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
        }
        
        .obstacle-results-content {
            margin-bottom: 10px;
        }
        
        .obstacle-result-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }
        
        .obstacle-result-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        .obstacle-result-count {
            font-weight: 600;
        }
        
        .clear-obstacles-btn {
            width: 100%;
            padding: 8px 12px;
            background: var(--color-dark);
            color: var(--color-light);
            border: none;
            border-radius: 6px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .clear-obstacles-btn:hover {
            background: var(--color-muted);
        }
        
        .obstacle-instruction {
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 6px;
            padding: 10px;
            margin-top: 8px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: var(--color-dark);
            text-align: center;
        }
        
        /* Add POC button in side panel */
        .add-poc-button {
            width: 100%;
            padding: 10px 16px;
            background: var(--color-dark);
            color: var(--color-light);
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            margin-top: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .add-poc-button:hover {
            background: var(--color-muted);
        }
        
        .add-poc-button.active {
            background: #dc2626;
        }
        
        .add-poc-button.active:hover {
            background: #b91c1c;
        }
        
        /* Instruction banner for add POC mode */
        .add-poc-instruction {
            background: #3b82f6;
            color: white;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 13px;
            text-align: center;
            margin-top: 12px;
        }
        
        /* Floating POC Panel (compact vertical card) */
        .poc-float-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(246, 246, 245, 0.92);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            padding: 10px 12px;
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(15, 17, 18, 0.18), 0 2px 8px rgba(0, 0, 0, 0.08);
            border: 1px solid var(--color-border);
            font-family: 'IBM Plex Mono', monospace;
            z-index: 1002;
            display: none;
            width: 360px;
        }
        
        .poc-float-panel.visible {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        
        .poc-float-panel-coords {
            font-size: 10px;
            color: #9ca3af;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            margin-bottom: 4px;
        }
        
        .poc-float-panel-results {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        
        .poc-float-result {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 4px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.04);
        }
        
        .poc-float-result:last-child {
            border-bottom: none;
        }
        
        .poc-float-result-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .poc-float-result-voltage {
            font-size: 11px;
            font-weight: 600;
            width: 100px;
            flex-shrink: 0;
        }
        
        .poc-float-result-type {
            font-size: 10px;
            color: #9ca3af;
            width: 38px;
            flex-shrink: 0;
        }
        
        .poc-float-result-distance {
            font-size: 11px;
            font-weight: 600;
            color: var(--color-dark);
            flex: 1;
            text-align: right;
        }
        
        .poc-float-result-shuffle {
            padding: 2px 5px;
            border-radius: 3px;
            border: 1px solid #e5e7eb;
            background: transparent;
            font-size: 10px;
            cursor: pointer;
            color: #9ca3af;
            transition: background 0.15s, color 0.15s;
            flex-shrink: 0;
            line-height: 1;
        }
        
        .poc-float-result-shuffle:hover {
            background: #f3f4f6;
            color: #374151;
        }
        
        .poc-float-panel-actions {
            display: flex;
            gap: 6px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.06);
            margin-top: 4px;
        }
        
        .poc-float-btn {
            padding: 6px 0;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s, transform 0.1s;
            white-space: nowrap;
            flex: 1;
            text-align: center;
        }
        
        .poc-float-btn:active {
            transform: scale(0.98);
        }
        
        .poc-float-btn-primary {
            background: var(--color-dark);
            color: white;
            border: none;
        }
        
        .poc-float-btn-primary:hover {
            background: #1f2937;
        }
        
        .poc-float-btn-secondary {
            background: #f9fafb;
            color: #374151;
            border: 1px solid #e5e7eb;
        }
        
        .poc-float-btn-secondary:hover {
            background: #f3f4f6;
        }
        
        .poc-float-btn-reset {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fcd34d;
        }
        
        .poc-float-btn-reset:hover {
            background: #fde68a;
        }
        
        .poc-float-empty {
            color: #9ca3af;
            font-size: 11px;
            padding: 8px 0;
            text-align: center;
        }
        
        /* Side Panel */
        .side-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            bottom: 10px;
            width: 360px;
            background: rgba(246, 246, 245, 0.88);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            box-shadow: 0 4px 24px rgba(15, 17, 18, 0.12);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            z-index: 1001;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        
        .side-panel.visible {
            display: flex;
        }
        
        .side-panel-header {
            padding: 14px 16px;
            border-bottom: 1px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        
        .side-panel-header h3 {
            font-size: 13px;
            font-weight: 600;
            color: var(--color-dark);
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .side-panel-close {
            background: none;
            border: none;
            padding: 6px;
            cursor: pointer;
            color: var(--color-muted);
            border-radius: 6px;
            transition: all 0.2s;
        }
        
        .side-panel-close:hover {
            background: var(--color-border);
            color: var(--color-dark);
        }
        
        .side-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px 16px;
        }
        
        /* Site list view */
        .site-list-controls {
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .site-list-search {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--color-border);
        }
        
        .site-list-search input {
            border: none;
            outline: none;
            background: transparent;
            flex: 1;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: var(--color-dark);
        }
        
        .site-list-search input::placeholder {
            color: var(--color-muted);
        }
        
        .site-list-sort {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            font-size: 10px;
            color: var(--color-muted);
        }
        
        .site-list-sort select {
            flex: 1;
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--color-border);
            background: rgba(255, 255, 255, 0.7);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 10px;
            color: var(--color-dark);
            cursor: pointer;
        }
        
        .site-list-sort select:focus {
            outline: none;
            border-color: var(--color-muted);
            box-shadow: 0 0 0 2px rgba(102, 109, 112, 0.15);
        }
        
        .site-list-item {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 12px 14px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .site-list-item:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: var(--color-muted);
        }
        
        .site-list-item-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--color-dark);
            margin-bottom: 6px;
        }
        
        .site-list-item-meta {
            display: flex;
            gap: 12px;
            font-size: 11px;
            color: var(--color-muted);
        }
        
        .site-list-item-voltages {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }
        
        .site-list-voltage-tag {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            color: white;
        }
        
        /* Site selector */
        .site-selector {
            margin-bottom: 16px;
        }
        
        .site-selector label {
            font-size: 10px;
            color: var(--color-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: block;
            margin-bottom: 6px;
        }
        
        .site-selector select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            font-size: 13px;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.6);
            color: #1f2937;
            background: white;
            cursor: pointer;
        }
        
        .site-selector select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Site info */
        .site-info {
            background: rgba(255, 255, 255, 0.5);
            border: 1px solid var(--color-border);
            padding: 12px 14px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .site-info-name-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .site-info-name {
            font-weight: 600;
            color: var(--color-dark);
            font-size: 14px;
            flex: 1;
        }
        
        .site-rename-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6b7280;
        }
        
        .site-rename-btn:hover {
            opacity: 1;
            color: #374151;
        }
        
        .site-info-coords {
            font-size: 12px;
            color: #6b7280;
        }
        
        .site-info-parcel {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            font-size: 11px;
            color: #6b7280;
        }
        
        .parcel-popup {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
        }
        
        .parcel-popup strong {
            display: block;
            margin-bottom: 4px;
        }
        
        .parcel-popup button {
            margin-top: 8px;
        }
        
        .site-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .site-action-btn {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            font-weight: 500;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--color-dark);
        }
        
        .site-action-btn:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: var(--color-muted);
        }
        
        .site-action-btn.danger {
            color: #dc2626;
            border-color: #fecaca;
        }
        
        .site-action-btn.danger:hover {
            background: #fef2f2;
        }
        
        /* POC section */
        .poc-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        
        .poc-section-title {
            font-size: 10px;
            color: var(--color-muted);
            text-transform: uppercase;
        }
        
        .add-custom-poc-btn {
            padding: 5px 10px;
            font-size: 11px;
            background: var(--color-dark);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .add-custom-poc-btn:hover {
            background: #374151;
        }
        
        .add-custom-poc-btn.active {
            background: #dc2626;
        }
        
        .add-custom-poc-btn.active:hover {
            background: #b91c1c;
        }
        
        .add-custom-poc-instruction {
            background: #dbeafe;
            color: #1e40af;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 12px;
            margin-bottom: 12px;
            text-align: center;
            letter-spacing: 0.5px;
        }
        
        .route-toggle-btn {
            padding: 4px 10px;
            font-size: 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 500;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            color: var(--color-muted);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .route-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.9);
            color: var(--color-dark);
        }
        
        .route-toggle-btn.active {
            background: var(--color-dark);
            color: var(--color-light);
            border-color: var(--color-dark);
        }
        
        .poc-count {
            background: #e5e7eb;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            color: #374151;
        }
        
        /* POC card */
        .poc-card {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        
        .poc-card.accepted {
            border-color: #86efac;
            background: #f0fdf4;
        }
        
        .poc-card.rejected {
            border-color: #fecaca;
            background: #fef2f2;
            opacity: 0.6;
        }
        
        .poc-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .poc-voltage-badge {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 700;
            color: white;
            text-align: center;
            min-width: 50px;
        }
        
        .poc-power-range {
            font-size: 15px;
            font-weight: 600;
            color: #111827;
        }
        
        .poc-card-info {
            flex: 1;
        }
        
        .poc-card-distance {
            font-size: 13px;
            color: #6b7280;
        }
        
        .poc-card-type {
            font-size: 12px;
            color: #6b7280;
        }
        
        .poc-custom-badge {
            background: #8b5cf6;
            color: white;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 4px;
        }
        
        /* Obstacle indicators - simplified */
        .poc-obstacles-loading {
            font-size: 11px;
            color: var(--color-muted);
            padding: 4px 0;
        }
        
        .poc-obstacles-summary {
            font-size: 11px;
            padding: 6px 10px;
            margin: 6px 0;
            border-radius: 4px;
        }
        
        .poc-obstacles-summary.warning {
            background: rgba(168, 85, 247, 0.1);
            color: #7c3aed;
        }
        
        .poc-obstacles-summary.clear {
            background: rgba(34, 197, 94, 0.1);
            color: #15803d;
        }
        
        .poc-card.has-crossings {
            border-color: rgba(168, 85, 247, 0.4);
        }
        
        /* Obstacle crossing marker on map - black circle */
        .obstacle-crossing-marker {
            width: 8px;
            height: 8px;
            background: var(--color-dark);
            border: 1.5px solid white;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .poc-card-actions {
            display: flex;
            gap: 8px;
        }
        
        .poc-action-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .poc-action-btn.accept {
            background: #dcfce7;
            color: #166534;
        }
        
        .poc-action-btn.accept:hover {
            background: #bbf7d0;
        }
        
        .poc-action-btn.reject {
            background: #fee2e2;
            color: #dc2626;
        }
        
        .poc-action-btn.reject:hover {
            background: #fecaca;
        }
        
        .poc-action-btn.undo {
            background: #f3f4f6;
            color: #374151;
        }
        
        .poc-action-btn.undo:hover {
            background: #e5e7eb;
        }
        
        .poc-action-btn.route {
            background: #dbeafe;
            color: #1d4ed8;
        }
        
        .poc-action-btn.route:hover {
            background: #bfdbfe;
        }
        
        .poc-action-btn.route.active {
            background: #1d4ed8;
            color: white;
        }
        
        .poc-action-btn.route:disabled {
            background: #e5e7eb;
            color: #9ca3af;
            cursor: not-allowed;
        }
        
        /* Waypoints info */
        .poc-waypoints-info {
            font-size: 10px;
            color: #1d4ed8;
            margin-top: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        /* Loading state */
        .poc-loading {
            text-align: center;
            padding: 40px 20px;
            color: #6b7280;
        }
        
        .poc-loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 12px;
        }
        
        /* Empty state */
        .poc-empty {
            text-align: center;
            padding: 40px 20px;
            color: #6b7280;
        }
        
        .poc-empty svg {
            width: 48px;
            height: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        
        /* Site marker custom icon - black pin */
        .site-marker-icon {
            width: 24px;
            height: 32px;
            position: relative;
        }
        .site-marker-icon::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: #1f2937;
            border: 1px solid white;
            border-radius: 50% 50% 50% 0;
            transform: translateX(-50%) rotate(-45deg);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }
        .site-marker-icon::after {
            content: '';
            position: absolute;
            top: 6px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
        }
        
        
        /* Embedded capacity marker - diamond shape */
        .embedded-capacity-marker {
            border-radius: 2px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);

            border: solid #ffffff;  /* Width set inline based on zoom */
        }
        
        /* Connected: purple diamond */
        .embedded-capacity-marker.connected {
            background: #8b5cf6;
        }
        
        /* Accepted: lighter purple diamond */
        .embedded-capacity-marker.accepted {
            background: #c1a9fa;
        }
        
        /* Infrastructure projects marker - hexagon shape */
        .infrastructure-project-marker {
            border-radius: 3px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
            border: solid #ffffff;
            background: #f59e0b;  /* Amber/orange color */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }
        
        /* Embedded capacity filter section */
        .embedded-filter-section {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--color-border);
        }
        
        .embedded-filter-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--color-dark);
            margin-bottom: 6px;
        }
        
        /* Date slider section */
        .date-slider-container {
            margin: 6px 0 0 0;
        }
        
        .date-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: #f3f4f6;
            border-radius: 4px;
        }
        
        .date-display .current-date {
            font-size: 12px;
            font-weight: 600;
            color: var(--color-dark);
        }
        
        .date-display .date-range {
            font-size: 9px;
            color: var(--color-muted);
        }
        
        #embedded-date-slider {
            margin-top: 6px;
        }
        
        #embedded-date-slider .noUi-connect {
            background: #656565;
        }
        
        #embedded-date-slider .noUi-handle {
            width: 14px;
            height: 14px;
            right: -7px;
            top: -5px;
            border-radius: 50%;
            background: #898989;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        #embedded-date-slider .noUi-handle:before,
        #embedded-date-slider .noUi-handle:after {
            display: none;
        }
        
        /* Resource type filter - compact 2-column grid */
        .resource-type-filters {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
            margin-top: 4px;
        }
        
        .resource-type-toggle {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 3px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            color: var(--color-dark);
            transition: background-color 0.15s ease;
        }
        
        .resource-type-toggle:hover {
            background: #f3f4f6;
        }
        
        .resource-type-toggle .resource-icon {
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }
        
        .resource-type-toggle .resource-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .resource-type-toggle .resource-check {
            opacity: 1;
            color: #8b5cf6;
            font-weight: bold;
            font-size: 10px;
            transition: opacity 0.15s ease;
        }
        
        .resource-type-toggle.hidden .resource-check {
            opacity: 0.3;
        }
        
        .resource-type-toggle.hidden .resource-name,
        .resource-type-toggle.hidden .resource-icon {
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- POC Mode distance tooltip -->
    <div class="poc-tooltip" id="poc-tooltip">
        <div id="poc-tooltip-content"></div>
    </div>
    
    <!-- Floating POC Panel (Figma-style bottom panel, wide layout) -->
    <div class="poc-float-panel" id="poc-float-panel">
        <div class="poc-float-panel-coords" id="poc-float-coords"></div>
        <div class="poc-float-panel-results" id="poc-float-results"></div>
        <div class="poc-float-panel-actions" id="poc-float-actions"></div>
    </div>
    
    <div class="loading-overlay" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading NPG network data...</div>
        <div class="loading-progress" id="loading-progress">0 / 3 data sources loaded</div>
    </div>
    
    <!-- Side Panel for POCs -->
    <div class="side-panel" id="side-panel">
        <div class="side-panel-header">
            <h3>Sites</h3>
            <button class="side-panel-close" onclick="deselectSite()">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="side-panel-content" id="side-panel-content">
            <!-- Content populated by JavaScript -->
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
            crossorigin=""></script>
    
    <!-- Leaflet Heat Plugin -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    
    <!-- PDF Generation Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- noUiSlider JS -->
    <script src="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.js"></script>
    
    <!-- Turf.js for geometric calculations -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    
    <!-- Proj4js for coordinate transformation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.2/proj4.js"></script>
    
    <script>
        // Configuration
        const CONFIG = {
            // Map center (roughly center of NPG coverage area - Northern England)
            center: [54.0, -1.5],
            zoom: 8,
            minZoom: 6,
            maxZoom: 18
        };

        // Layer definitions with colors and MVA ranges (voltage-based layers)
        // NPG Cable Layers - features are loaded from multiple source files and sorted by voltage
        const LAYERS = [
            {
                name: 'HV Network',
                color: '#ef4444',  // Red
                weight: 1.5,
                mvaMin: 0.5,
                mvaMax: 5,
                voltageVolts: [6600, 11000, 20000]
            },
            {
                name: '33kV',
                color: '#4ade80',  // Light green
                weight: 2,
                mvaMin: 3,
                mvaMax: 30,
                voltageVolts: 33000
            },
            {
                name: '66kV',
                color: '#16a34a',  // Dark green
                weight: 2,
                mvaMin: 20,
                mvaMax: 60,
                voltageVolts: 66000
            },
            {
                name: '132kV',
                color: '#f97316',  // Orange
                weight: 2.5,
                mvaMin: 20,
                mvaMax: 100,
                voltageVolts: 132000
            }
        ];
        
        // NPG GeoJSON data sources - each file contains features at multiple voltages
        const DATA_SOURCES = [
            {
                file: 'npg-ehv-feeders.geojson',
                voltageField: 'voltage',       // Field name containing voltage in volts
                typeField: 'situation'          // OVERHEAD or UNDERGROUND
            },
            {
                file: 'npg-hv-overhead-feeders.geojson',
                voltageField: 'operating_voltage',
                typeField: 'line_situation_actual'
            },
            {
                file: 'npg-hv-underground-cables.geojson',
                voltageField: 'voltage_v',
                typeField: 'line_situation'
            }
        ];
        
        // Pole/Tower layer configurations - loaded from supports location file
        // Supports are loaded lazily (only when toggled on) due to large file size
        const POLE_TOWER_LAYERS = [
            {
                name: '33kV Supports',
                voltage: '33kV',
                voltageVolts: 33000,
                color: '#4ade80',
                mvaMin: 3,
                mvaMax: 30
            },
            {
                name: '66kV Supports',
                voltage: '66kV',
                voltageVolts: 66000,
                color: '#16a34a',
                mvaMin: 20,
                mvaMax: 60
            },
            {
                name: '132kV Supports',
                voltage: '132kV',
                voltageVolts: 132000,
                color: '#f97316',
                mvaMin: 20,
                mvaMax: 100
            }
        ];
        const SUPPORTS_FILE = 'ehv-and-hv-supports-location.geojson';
        let supportsLoaded = false; // Track if supports data has been loaded
        
        // Store pole/tower data for POC snapping
        const poleTowerData = {};  // { '33kV': [features...], '132kV': [features...] }
        let poleTowerLayerGroups = {};  // Leaflet layer groups by voltage
        let polesTowersVisible = false;  // Toggle state for poles/towers layer (default OFF)
        
        // Base radius for markers at zoom level 12 (will scale with zoom)
        const MARKER_BASE_RADIUS = 8;
        const MARKER_MIN_RADIUS = 2;
        const MARKER_MAX_RADIUS = 12;
        
        // Combined layers for display purposes
        const ALL_LAYERS = [...LAYERS];
        
        // Current filter range (default: show all voltage levels)
        let filterMin = 10;
        let filterMax = 20;
        
        // POC search distance (configurable via slider, default 10km)
        let POC_MAX_DISTANCE_KM = 10;
        
        // One-off POC click visuals (default mode)
        let singlePocLines = {};
        let singlePocMarkers = {};
        let singlePocClickPin = null;       // Pin marker at click location
        let singlePocClickLocation = null;  // Store last click location for "Add Site" button
        let singlePocResults = [];          // Current displayed results
        let singlePocOriginalResults = [];  // Original results for reset
        let singlePocSkipped = {};          // Track skipped features per voltage-type: { '11kV-Cable': [[lng,lat], ...], ... }
        
        // Store raw GeoJSON data for Turf.js calculations
        const rawGeoJSONData = {};
        
        // ============== SITE STATE ==============
        let sites = [];  // Array of saved sites
        let currentSiteId = null;  // Currently selected site
        let siteMarkers = {};  // Map of site ID to marker
        let pocMarkers = {};  // Map of POC ID to marker
        let pocLines = {};  // Map of POC ID to connection line
        let obstacleCrossingMarkers = {};  // Map of POC ID to array of crossing markers
        let obstaclesCache = {};  // Cache: pocId -> { crossings: [], fetched: boolean }
        let obstacleOverlays = {};  // Map of POC ID to array of obstacle overlay polygons
        
        // Custom POC mode state
        let addCustomPOCMode = false;  // Whether user is in "add custom POC" mode
        
        // Voltage levels and their power capacities (MVA)
        const VOLTAGE_POWER_RANGES = {
            'HV Network': { min: 0.4, max: 5, color: '#ef4444' },
            '33kV': { min: 3, max: 30, color: '#4ade80' },
            '66kV': { min: 20, max: 60, color: '#16a34a' },
            '132kV': { min: 20, max: 100, color: '#f97316' }
        };
        
        // Helper: find voltage layer config by voltage in volts
        function getVoltageLayerByVolts(volts) {
            return LAYERS.find(l => 
                Array.isArray(l.voltageVolts) 
                    ? l.voltageVolts.includes(volts) 
                    : l.voltageVolts === volts
            );
        }
        
        // Helper: convert voltage in volts to display name (e.g., 33000  '33kV')
        function voltsToName(volts) {
            const layer = getVoltageLayerByVolts(volts);
            return layer ? layer.name : `${volts/1000}kV`;
        }
        
        // Initialize map
        const map = L.map('map', {
            center: CONFIG.center,
            zoom: CONFIG.zoom,
            minZoom: CONFIG.minZoom,
            maxZoom: CONFIG.maxZoom,
            preferCanvas: true,  // Use canvas renderer for much faster rendering of large datasets
            zoomControl: false   // Disable default top-left zoom, we add our own below
        });
        
        // Add zoom control to bottom-left
        L.control.zoom({ position: 'bottomleft' }).addTo(map);

        // Base map layers
        const baseMaps = {
            'Light': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/attributions">CARTO</a> | NPG Network Data',
                subdomains: 'abcd',
                maxZoom: 20
            }),
            'Colour': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors | NPG Network Data',
                maxZoom: 19
            }),
            'Satellite': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '&copy; <a href="https://www.esri.com/">Esri</a> | NPG Network Data',
                maxZoom: 19
            })
        };

        // Add Light as default
        baseMaps['Light'].addTo(map);
        
        // Track current base map
        let currentBaseMap = 'Light';

        // Layer groups for control
        const layerGroups = {};
        
        let loadedCount = 0;
        let allBounds = null;
        
        // Cache for loaded GeoJSON files (to avoid reloading same file)
        const geoJSONCache = {};
        
        // Total data sources to load (cable data sources only - supports loaded lazily)
        const TOTAL_LAYERS = DATA_SOURCES.length;

        // Create popup content for cables
        function createPopupContent(properties, layerConfig, sourceConfig) {
            const voltage = layerConfig.name;
            const situation = properties.situation || properties.line_situation_actual || properties.line_situation || 'Unknown';
            const circuitName = properties.circuit_name || properties.circuit_id || '';
            const circuitSection = properties.circuit_section_name || properties.circuit_section_id || '';
            
            return `
                <div class="popup-content">
                    <span class="voltage-badge" style="background-color: ${layerConfig.color}">${voltage}</span>
                    <div><strong>Type:</strong> ${situation}</div>
                    <div><strong>DNO:</strong> Northern Powergrid</div>
                    ${circuitName ? `<div><strong>Circuit:</strong> ${circuitName}</div>` : ''}
                    ${circuitSection ? `<div><strong>Section:</strong> ${circuitSection}</div>` : ''}
                </div>
            `;
        }
        
        
        // (Embedded capacity and infrastructure projects not yet available for NPG)
        
        // Update pole/tower marker sizes based on zoom
        function updatePoleTowerSizes() {
            const zoom = map.getZoom();
            // Scale radius: 2px at zoom 6, 4px at zoom 12, 6px at zoom 16+
            const radius = Math.min(6, Math.max(2, 2 + (zoom - 6) * 0.4));
            const weight = zoom >= 14 ? 2 : (zoom >= 10 ? 1.5 : 1);
            
            POLE_TOWER_LAYERS.forEach(layerConfig => {
                const layerGroup = poleTowerLayerGroups[layerConfig.voltage];
                if (!layerGroup) return;
                
                layerGroup.eachLayer(marker => {
                    if (marker.setRadius) {
                        marker.setRadius(radius);
                        marker.setStyle({ weight: weight });
                    }
                });
            });
        }
        
        // (Infrastructure projects functions removed - not yet available for NPG)

        // Load a GeoJSON data source and distribute features to voltage-based layers
        async function loadDataSource(sourceConfig) {
            try {
                const response = await fetch(sourceConfig.file);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                
                // Distribute features by voltage into per-voltage GeoJSON collections
                data.features.forEach(feature => {
                    if (!feature.geometry) return;
                    
                    // Get voltage in volts from the source-specific field
                    const volts = feature.properties[sourceConfig.voltageField];
                    if (!volts) return;
                    
                    // Find matching voltage layer
                    const voltageLayer = getVoltageLayerByVolts(volts);
                    if (!voltageLayer) return;  // Skip unmapped voltages (e.g., 275kV)
                    
                    // Initialize raw GeoJSON data for this voltage if needed
                    if (!rawGeoJSONData[voltageLayer.name]) {
                        rawGeoJSONData[voltageLayer.name] = {
                            type: 'FeatureCollection',
                            features: []
                        };
                    }
                    rawGeoJSONData[voltageLayer.name].features.push(feature);
                });
                
                loadedCount++;
                updateProgress();
                return true;
            } catch (error) {
                console.error(`Failed to load ${sourceConfig.file}:`, error);
                loadedCount++;
                updateProgress();
                return false;
            }
        }
        
        // Build Leaflet layers from the collected rawGeoJSONData per voltage
        function buildVoltageLayers() {
            LAYERS.forEach(layerConfig => {
                const geoJSON = rawGeoJSONData[layerConfig.name];
                if (!geoJSON || !geoJSON.features || geoJSON.features.length === 0) return;
                
                const layer = L.geoJSON(geoJSON, {
                    style: {
                        color: layerConfig.color,
                        weight: layerConfig.weight,
                        opacity: 0.8
                    },
                    filter: (feature) => {
                        // Skip features with null geometry
                        return feature.geometry !== null;
                    },
                    onEachFeature: (feature, layer) => {
                        layer.bindPopup(createPopupContent(feature.properties, layerConfig));
                    }
                });
                
                layerGroups[layerConfig.name] = layer;
                layer.addTo(map);
                
                // Extend bounds
                const layerBounds = layer.getBounds();
                if (layerBounds.isValid()) {
                    if (allBounds === null) {
                        allBounds = layerBounds;
                    } else {
                        allBounds.extend(layerBounds);
                    }
                }
            });
        }
        
        // Update loading progress
        function updateProgress() {
            const progressEl = document.getElementById('loading-progress');
            progressEl.textContent = `${loadedCount} / ${TOTAL_LAYERS} data sources loaded`;
            
            if (loadedCount === TOTAL_LAYERS) {
                finishLoading();
            }
        }
        
        // Calculate marker radius based on zoom level
        function getMarkerRadius(zoom) {
            // At zoom 6 (min): 2px, at zoom 12+: 8px, interpolate between
            const minZoom = 6;
            const maxZoom = 12;
            
            if (zoom <= minZoom) return MARKER_MIN_RADIUS;
            if (zoom >= maxZoom) return MARKER_BASE_RADIUS;
            
            // Linear interpolation
            const t = (zoom - minZoom) / (maxZoom - minZoom);
            return MARKER_MIN_RADIUS + t * (MARKER_BASE_RADIUS - MARKER_MIN_RADIUS);
        }
        
        // Calculate border width based on zoom level (thinner at higher zoom)
        function getMarkerBorderWidth(zoom) {
            // At zoom 6: 2px, at zoom 14+: 1px
            if (zoom <= 8) return 2;
            if (zoom >= 14) return 1;
            return 1.5;
        }
        // Check if ranges overlap
        function rangesOverlap(userMin, userMax, layerMin, layerMax) {
            return userMin <= layerMax && userMax >= layerMin;
        }
        
        // Format MVA value for display
        function formatMVA(value) {
            if (value >= 1) {
                return value.toFixed(0);
            }
            return value.toFixed(1);
        }
        
        // Update layer visibility based on current MVA filter
        function updateLayerVisibility() {
            // Voltage indicator visibility tracking
            const voltageVisible = {};
            LAYERS.forEach(l => { voltageVisible[l.name] = false; });
            
            // Update cable layers
            LAYERS.forEach(layerConfig => {
                const layer = layerGroups[layerConfig.name];
                if (!layer) return;
                
                const shouldShow = rangesOverlap(filterMin, filterMax, layerConfig.mvaMin, layerConfig.mvaMax);
                
                if (shouldShow) {
                    if (!map.hasLayer(layer)) {
                        map.addLayer(layer);
                    }
                    voltageVisible[layerConfig.name] = true;
                } else {
                    if (map.hasLayer(layer)) {
                        map.removeLayer(layer);
                    }
                }
            });
            
            // Update voltage indicators in UI
            Object.entries(voltageVisible).forEach(([voltage, visible]) => {
                const indicator = document.getElementById(`indicator-${voltage.replace(/\./g, 'p').replace(/[^a-zA-Z0-9p]/g, '')}`);
                if (indicator) {
                    if (visible) {
                        indicator.classList.remove('hidden');
                    } else {
                        indicator.classList.add('hidden');
                    }
                }
            });
            
            // Update pole/tower layers visibility based on toggle AND MVA filter
            POLE_TOWER_LAYERS.forEach(layerConfig => {
                const layerGroup = poleTowerLayerGroups[layerConfig.voltage];
                if (!layerGroup) return;
                
                const voltageInRange = rangesOverlap(filterMin, filterMax, layerConfig.mvaMin, layerConfig.mvaMax);
                const shouldShow = polesTowersVisible && voltageInRange;
                
                if (shouldShow) {
                    if (!map.hasLayer(layerGroup)) {
                        map.addLayer(layerGroup);
                    }
                } else {
                    if (map.hasLayer(layerGroup)) {
                        map.removeLayer(layerGroup);
                    }
                }
            });
            
            // Update poles/towers toggle indicator
            const polesTowersToggle = document.getElementById('toggle-poles-towers');
            if (polesTowersToggle) {
                if (polesTowersVisible) {
                    polesTowersToggle.classList.remove('hidden');
                } else {
                    polesTowersToggle.classList.add('hidden');
                }
            }
        }
        
        // Update the MVA display values
        function updateMVADisplay() {
            document.getElementById('mva-min').textContent = formatMVA(filterMin);
            document.getElementById('mva-max').textContent = formatMVA(filterMax);
        }
        
        // ============== POC MODE FUNCTIONS ==============
        
        // Format distance for display (auto: meters < 1km, else km)
        function formatDistance(meters) {
            if (meters < 1000) {
                return `${Math.round(meters)}m`;
            }
            return `${(meters / 1000).toFixed(2)}km`;
        }
        
        // Throttle function for performance
        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }
        
        // Get visible layer names (filtered by MVA) - cables only
        function getVisibleLayerNames() {
            return LAYERS
                .filter(l => rangesOverlap(filterMin, filterMax, l.mvaMin, l.mvaMax))
                .map(l => l.name);
        }
        
        // Get layer config by name
        function getLayerConfig(name) {
            return LAYERS.find(l => l.name === name);
        }
        
        // Find nearest point on all visible cables within max distance
        function findNearestConnection(cursorLat, cursorLng) {
            const cursorPoint = turf.point([cursorLng, cursorLat]);
            const visibleLayerNames = getVisibleLayerNames();
            
            let nearestResult = null;
            let nearestDistance = Infinity;
            let nearestLayerConfig = null;
            
            // Create a bounding box for search radius
            const searchBuffer = turf.buffer(cursorPoint, POC_MAX_DISTANCE_KM, { units: 'kilometers' });
            const searchBbox = turf.bbox(searchBuffer);
            
            visibleLayerNames.forEach(layerName => {
                const geoJSON = rawGeoJSONData[layerName];
                if (!geoJSON || !geoJSON.features) return;
                
                const layerConfig = getLayerConfig(layerName);
                if (!layerConfig) return;
                
                geoJSON.features.forEach(feature => {
                    if (!feature.geometry) return;
                    
                    // Quick bounding box check for performance
                    const featureBbox = turf.bbox(feature);
                    if (featureBbox[0] > searchBbox[2] || featureBbox[2] < searchBbox[0] ||
                        featureBbox[1] > searchBbox[3] || featureBbox[3] < searchBbox[1]) {
                        return; // Skip features outside search area
                    }
                    
                    try {
                        // Handle LineString and MultiLineString (cables)
                        let lines = [];
                        if (feature.geometry.type === 'LineString') {
                            lines = [feature];
                        } else if (feature.geometry.type === 'MultiLineString') {
                            lines = feature.geometry.coordinates.map(coords => 
                                turf.lineString(coords)
                            );
                        }
                        
                        lines.forEach(line => {
                            const nearest = turf.nearestPointOnLine(line, cursorPoint, { units: 'meters' });
                            const distance = nearest.properties.dist;
                            
                            if (distance < nearestDistance && distance <= POC_MAX_DISTANCE_KM * 1000) {
                                nearestDistance = distance;
                                nearestResult = nearest;
                                nearestLayerConfig = layerConfig;
                            }
                        });
                    } catch (e) {
                        // Skip invalid geometries
                    }
                });
            });
            
            if (nearestResult && nearestDistance <= POC_MAX_DISTANCE_KM * 1000) {
                return {
                    point: nearestResult,
                    distance: nearestDistance,
                    layerConfig: nearestLayerConfig
                };
            }
            
            return null;
        }
        
        // Find nearest point on cables of a specific voltage (for snapping when dragging POC endpoint)
        function findNearestCablePoint(lat, lng, voltage, preferredLayerName) {
            const cursorPoint = turf.point([lng, lat]);
            let nearestPoint = null;
            let nearestDistance = Infinity;
            
            // First try the preferred layer (original cable)
            const layersToSearch = [];
            if (preferredLayerName && rawGeoJSONData[preferredLayerName]) {
                layersToSearch.push(preferredLayerName);
            }
            
            // Also search other layers with same voltage
            Object.keys(rawGeoJSONData).forEach(layerName => {
                if (layerName !== preferredLayerName && extractVoltage(layerName) === voltage) {
                    layersToSearch.push(layerName);
                }
            });
            
            layersToSearch.forEach(layerName => {
                const geoJSON = rawGeoJSONData[layerName];
                if (!geoJSON || !geoJSON.features) return;
                
                geoJSON.features.forEach(feature => {
                    if (!feature.geometry) return;
                    
                    try {
                        let candidatePoint = null;
                        let candidateDistance = Infinity;
                        
                        if (feature.geometry.type === 'LineString') {
                            const nearestOnLine = turf.nearestPointOnLine(feature, cursorPoint, { units: 'meters' });
                            candidateDistance = nearestOnLine.properties.dist;
                            candidatePoint = {
                                lat: nearestOnLine.geometry.coordinates[1],
                                lng: nearestOnLine.geometry.coordinates[0]
                            };
                        } else if (feature.geometry.type === 'MultiLineString') {
                            feature.geometry.coordinates.forEach(lineCoords => {
                                try {
                                    const line = turf.lineString(lineCoords);
                                    const nearestOnLine = turf.nearestPointOnLine(line, cursorPoint, { units: 'meters' });
                                    if (nearestOnLine.properties.dist < candidateDistance) {
                                        candidateDistance = nearestOnLine.properties.dist;
                                        candidatePoint = {
                                            lat: nearestOnLine.geometry.coordinates[1],
                                            lng: nearestOnLine.geometry.coordinates[0]
                                        };
                                    }
                                } catch (e) {}
                            });
                        }
                        
                        if (candidatePoint && candidateDistance < nearestDistance) {
                            nearestDistance = candidateDistance;
                            nearestPoint = candidatePoint;
                        }
                    } catch (e) {}
                });
            });
            
            return nearestPoint;
        }
        
        // Clear one-off POC visuals and all state
        function clearSinglePOC() {
            clearSinglePOCVisuals();
            singlePocClickLocation = null;
            singlePocResults = [];
            singlePocOriginalResults = [];
            singlePocSkipped = {};
        }
        
        // Reverse geocode to get address from coordinates
        async function reverseGeocode(lat, lng) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=16&addressdetails=1`, {
                    headers: { 'User-Agent': 'POC-Finder-App' }
                });
                
                if (!response.ok) return null;
                
                const data = await response.json();
                if (data && data.address) {
                    // Build a short address from components
                    const addr = data.address;
                    const parts = [];
                    
                    // Try to get road/place name
                    if (addr.road) parts.push(addr.road);
                    else if (addr.hamlet) parts.push(addr.hamlet);
                    else if (addr.village) parts.push(addr.village);
                    else if (addr.suburb) parts.push(addr.suburb);
                    
                    // Add locality
                    if (addr.village && !parts.includes(addr.village)) parts.push(addr.village);
                    else if (addr.town) parts.push(addr.town);
                    else if (addr.city) parts.push(addr.city);
                    
                    if (parts.length > 0) {
                        return parts.slice(0, 2).join(', ');
                    }
                }
                return null;
            } catch (e) {
                console.warn('Reverse geocoding failed:', e);
                return null;
            }
        }
        
        // Generate default site name from coordinates
        function generateSiteName(lat, lng) {
            return `Site at ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
        }
        
        // Add site from single POC click location
        async function addSiteFromSinglePOC() {
            if (!singlePocClickLocation) return;
            
            const lat = singlePocClickLocation.lat;
            const lng = singlePocClickLocation.lng;
            
            // Generate a temporary name while we fetch the address
            let siteName = generateSiteName(lat, lng);
            
            // Create the site immediately with coordinate-based name
            const site = {
                id: generateId(),
                name: siteName,
                lat: lat,
                lng: lng,
                pocs: []
            };
            
            sites.push(site);
            saveSitesToStorage();
            
            // Add marker
            siteMarkers[site.id] = createSiteMarker(site);
            siteMarkers[site.id].addTo(map);
            
            // Clear the single POC visuals
            clearSinglePOC();
            
            // Select and discover POCs
            selectSite(site.id);
            discoverPOCs(site.id);
            
            // Try to get a better name from reverse geocoding (async)
            const address = await reverseGeocode(lat, lng);
            if (address) {
                site.name = address;
                saveSitesToStorage();
                
                // Update marker popup
                if (siteMarkers[site.id]) {
                    siteMarkers[site.id].setPopupContent(`<strong>${site.name}</strong><br>Click to view POCs`);
                }
                
                // Update side panel if this site is selected
                if (currentSiteId === site.id) {
                    renderSidePanel();
                }
            }
        }
        
        // Rename a site
        function renameSite(siteId) {
            const site = sites.find(s => s.id === siteId);
            if (!site) return;
            
            const newName = prompt('Enter new site name:', site.name);
            if (newName && newName.trim() !== '' && newName.trim() !== site.name) {
                site.name = newName.trim();
                saveSitesToStorage();
                
                // Update marker popup
                if (siteMarkers[siteId]) {
                    siteMarkers[siteId].setPopupContent(`<strong>${site.name}</strong><br>Click to view POCs`);
                }
                
                // Update side panel
                renderSidePanel();
            }
        }
        
        // Handle default map click: one-time POC calculation or custom POC addition
        function handleSinglePOCClick(e) {
            
            // Ignore clicks inside controls
            if (e.originalEvent && e.originalEvent.target.closest && e.originalEvent.target.closest('.leaflet-control')) {
                return;
            }
            
            // If in custom POC mode, add a custom POC
            if (addCustomPOCMode && currentSiteId) {
                addCustomPOC(e.latlng);
                return;
            }
            
            // Otherwise, run one-off POC calculation at click location
            runSinglePOCAt(e.latlng);
        }
        
        // Run one-off POC calculation at a given point
        function runSinglePOCAt(latlng, isReset = true) {
            // Clear any existing visuals
            clearSinglePOCVisuals();
            
            // Store click location for "Add Site" button
            singlePocClickLocation = { lat: latlng.lat, lng: latlng.lng };
            
            // Reset skipped if this is a fresh click (not a shuffle)
            if (isReset) {
                singlePocSkipped = {};
            }
            
            // Find nearest connections per voltage, excluding skipped
            const results = findSinglePOCResults(latlng.lat, latlng.lng);
            
            // Store results
            singlePocResults = results;
            if (isReset) {
                singlePocOriginalResults = JSON.parse(JSON.stringify(results));
            }
            
            if (results.length === 0) {
                // No connections found within range - show floating panel with message
                // Add pin at click location
                const pinIcon = L.divIcon({
                    className: '',
                    html: `<div style="
                        width: 24px;
                        height: 24px;
                        position: relative;
                    ">
                        <div style="
                            width: 16px;
                            height: 16px;
                            background: #6b7280;
                            border: 3px solid white;
                            border-radius: 50% 50% 50% 0;
                            transform: rotate(-45deg);
                            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                            position: absolute;
                            top: 0;
                            left: 4px;
                        "></div>
                    </div>`,
                    iconSize: [24, 24],
                    iconAnchor: [12, 24]
                });
                singlePocClickPin = L.marker([latlng.lat, latlng.lng], { icon: pinIcon }).addTo(map);
                
                updateFloatingPOCPanel([], latlng);
                return;
            }
            
            // Draw and show popup
            renderSinglePOCVisuals(results, latlng);
        }
        
        // Find POC results excluding skipped features
        function findSinglePOCResults(lat, lng) {
            const results = [];
            const sitePoint = turf.point([lng, lat]);
            const visibleLayerNames = getVisibleLayerNames();
            const searchBuffer = turf.buffer(sitePoint, POC_MAX_DISTANCE_KM, { units: 'kilometers' });
            const searchBbox = turf.bbox(searchBuffer);
            
            // Track nearest per voltage-type
            const nearestMap = {};
            
            visibleLayerNames.forEach(layerName => {
                const geoJSON = rawGeoJSONData[layerName];
                if (!geoJSON || !geoJSON.features) return;
                
                const layerConfig = getLayerConfig(layerName);
                if (!layerConfig) return;
                
                const voltage = extractVoltage(layerName);
                if (!voltage) return;
                
                const type = 'Cable';
                // Use just voltage as key - find nearest cable per voltage
                const key = voltage;
                const skippedPoints = singlePocSkipped[key] || [];
                
                geoJSON.features.forEach((feature) => {
                    if (!feature.geometry) return;
                    
                    // Quick bounding box check
                    const featureBbox = turf.bbox(feature);
                    if (featureBbox[0] > searchBbox[2] || featureBbox[2] < searchBbox[0] ||
                        featureBbox[1] > searchBbox[3] || featureBbox[3] < searchBbox[1]) {
                        return;
                    }
                    
                    try {
                        let candidatePoint = null;
                        let candidateDistance = Infinity;
                        
                        if (feature.geometry.type === 'LineString') {
                            const nearestOnLine = turf.nearestPointOnLine(feature, sitePoint, { units: 'meters' });
                            candidateDistance = nearestOnLine.properties.dist;
                            candidatePoint = {
                                lat: nearestOnLine.geometry.coordinates[1],
                                lng: nearestOnLine.geometry.coordinates[0]
                            };
                        } else if (feature.geometry.type === 'MultiLineString') {
                            feature.geometry.coordinates.forEach(lineCoords => {
                                try {
                                    const line = turf.lineString(lineCoords);
                                    const nearestOnLine = turf.nearestPointOnLine(line, sitePoint, { units: 'meters' });
                                    if (nearestOnLine.properties.dist < candidateDistance) {
                                        candidateDistance = nearestOnLine.properties.dist;
                                        candidatePoint = {
                                            lat: nearestOnLine.geometry.coordinates[1],
                                            lng: nearestOnLine.geometry.coordinates[0]
                                        };
                                    }
                                } catch (e) {}
                            });
                        }
                        
                        if (!candidatePoint || candidateDistance > POC_MAX_DISTANCE_KM * 1000) return;
                        
                        // Check if this point is in a similar direction to any skipped point
                        // Use 45-degree threshold - the next cable should be in a different direction
                        const MIN_ANGLE_DIFFERENCE = 45; // degrees
                        const candidateBearing = turf.bearing(
                            turf.point([lng, lat]),
                            turf.point([candidatePoint.lng, candidatePoint.lat])
                        );
                        
                        const isSkipped = skippedPoints.some(sp => {
                            const skippedBearing = turf.bearing(
                                turf.point([lng, lat]),
                                turf.point([sp.lng, sp.lat])
                            );
                            // Calculate angular difference (handle wrap-around at 180/-180)
                            let angleDiff = Math.abs(candidateBearing - skippedBearing);
                            if (angleDiff > 180) angleDiff = 360 - angleDiff;
                            return angleDiff < MIN_ANGLE_DIFFERENCE;
                        });
                        
                        if (isSkipped) return;
                        
                        // Track if this is closer than current best for this key
                        if (!nearestMap[key] || candidateDistance < nearestMap[key].distance) {
                            nearestMap[key] = {
                                voltage,
                                type,
                                lat: candidatePoint.lat,
                                lng: candidatePoint.lng,
                                distance: candidateDistance,
                                layerConfig
                            };
                        }
                    } catch (e) {}
                });
            });
            
            // For each voltage result, try to snap to a nearby pole/tower (only if poles layer is enabled)
            if (polesTowersVisible) {
                const sitePointForSnap = turf.point([lng, lat]);
                Object.keys(nearestMap).forEach(voltage => {
                    const cableResult = nearestMap[voltage];
                    if (!cableResult) return;
                    
                    // Look for a pole/tower within 200m of the cable point
                    const nearestPole = findNearestPoleTower(cableResult.lat, cableResult.lng, voltage, 200);
                    
                    if (nearestPole) {
                        // Recalculate distance from site to pole
                        const polePoint = turf.point([nearestPole.lng, nearestPole.lat]);
                        const distanceFromSite = turf.distance(sitePointForSnap, polePoint, { units: 'meters' });
                        
                        // Update result to snap to pole/tower
                        cableResult.lat = nearestPole.lat;
                        cableResult.lng = nearestPole.lng;
                        cableResult.distance = distanceFromSite;
                        cableResult.type = 'Pole/Tower';
                        cableResult.poleInfo = nearestPole.properties;
                    }
                });
            }
            
            // Convert map to results array, sorted by distance
            // Return all results with different voltages that are within range
            const allResults = Object.values(nearestMap).sort((a, b) => a.distance - b.distance);
            
            // Pick all results with different voltages (one per voltage)
            const selectedResults = [];
            for (const result of allResults) {
                const alreadyHasVoltage = selectedResults.some(r => r.voltage === result.voltage);
                if (!alreadyHasVoltage) {
                    selectedResults.push(result);
                }
            }
            
            return selectedResults;
        }
        
        // Render single POC visuals (lines, markers, floating panel)
        function renderSinglePOCVisuals(results, latlng) {
            const clickLatLng = [latlng.lat, latlng.lng];
            
            // Add pin marker at click location
            if (!singlePocClickPin) {
                const pinIcon = L.divIcon({
                    className: '',
                    html: `<div style="
                        width: 24px;
                        height: 24px;
                        position: relative;
                    ">
                        <div style="
                            width: 16px;
                            height: 16px;
                            background: #0f1112;
                            border: 3px solid white;
                            border-radius: 50% 50% 50% 0;
                            transform: rotate(-45deg);
                            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                            position: absolute;
                            top: 0;
                            left: 4px;
                        "></div>
                    </div>`,
                    iconSize: [24, 24],
                    iconAnchor: [12, 24]
                });
                singlePocClickPin = L.marker(clickLatLng, { icon: pinIcon }).addTo(map);
            } else {
                singlePocClickPin.setLatLng(clickLatLng);
            }
            
            // Draw lines and endpoint markers for each voltage
            results.forEach(r => {
                const color = VOLTAGE_POWER_RANGES[r.voltage]?.color || '#6b7280';
                const key = r.voltage;
                
                const line = L.polyline([
                    clickLatLng,
                    [r.lat, r.lng]
                ], {
                    color,
                    weight: 3,
                    dashArray: '8, 8',
                    opacity: 0.9
                }).addTo(map);
                
                singlePocLines[key] = line;
                
                const marker = L.circleMarker([r.lat, r.lng], {
                    radius: 7,
                    fillColor: color,
                    color: 'white',
                    weight: 2,
                    fillOpacity: 1
                }).addTo(map);
                
                singlePocMarkers[key] = marker;
            });
            
            // Update floating panel
            updateFloatingPOCPanel(results, latlng);
        }
        
        // Update the floating POC panel content
        function updateFloatingPOCPanel(results, latlng) {
            const panel = document.getElementById('poc-float-panel');
            const coordsEl = document.getElementById('poc-float-coords');
            const resultsEl = document.getElementById('poc-float-results');
            const actionsEl = document.getElementById('poc-float-actions');
            
            // Update coordinates display
            coordsEl.textContent = `${latlng.lat.toFixed(5)}, ${latlng.lng.toFixed(5)}`;
            
            // Check if any shuffling has occurred
            const hasShuffled = Object.keys(singlePocSkipped).length > 0;
            
            // Build results HTML (horizontal layout, all matching voltages)
            if (results.length === 0) {
                resultsEl.innerHTML = `<div class="poc-float-empty">No connections found within ${Math.round(POC_MAX_DISTANCE_KM)}km</div>`;
            } else {
                resultsEl.innerHTML = results.map(r => {
                    const color = VOLTAGE_POWER_RANGES[r.voltage]?.color || '#6b7280';
                    return `
                        <div class="poc-float-result">
                            <span class="poc-float-result-dot" style="background:${color}"></span>
                            <span class="poc-float-result-voltage">${r.voltage}</span>
                            <span class="poc-float-result-type">${r.type || ''}</span>
                            <span class="poc-float-result-distance">${formatDistance(r.distance)}</span>
                            <button class="poc-float-result-shuffle" onclick="shuffleSinglePOC('${r.voltage}')" title="Find next nearest in different direction"></button>
                        </div>
                    `;
                }).join('');
            }
            
            // Build actions HTML (side by side on the right)
            let actionsHTML = '<button class="poc-float-btn poc-float-btn-primary" onclick="addSiteFromSinglePOC()">Add Site</button>';
            
            if (hasShuffled) {
                actionsHTML += '<button class="poc-float-btn poc-float-btn-reset" onclick="resetSinglePOC()">Reset</button>';
            }
            
            actionsHTML += '<button class="poc-float-btn poc-float-btn-secondary" onclick="clearSinglePOC()">Clear</button>';
            
            actionsEl.innerHTML = actionsHTML;
            
            // Show panel
            panel.classList.add('visible');
        }
        
        // Shuffle to next nearest for a specific voltage-type
        function shuffleSinglePOC(voltage) {
            if (!singlePocClickLocation) return;
            
            const key = voltage;
            
            // Find current result for this voltage
            const currentResult = singlePocResults.find(r => r.voltage === voltage);
            if (!currentResult) return;
            
            // Add current point to skipped list
            if (!singlePocSkipped[key]) {
                singlePocSkipped[key] = [];
            }
            singlePocSkipped[key].push({ lat: currentResult.lat, lng: currentResult.lng });
            
            // Re-run search (not a reset, so skipped list is preserved)
            runSinglePOCAt({ lat: singlePocClickLocation.lat, lng: singlePocClickLocation.lng }, false);
        }
        
        // Reset to original results
        function resetSinglePOC() {
            if (!singlePocClickLocation) return;
            
            // Clear skipped and re-run
            singlePocSkipped = {};
            runSinglePOCAt({ lat: singlePocClickLocation.lat, lng: singlePocClickLocation.lng }, true);
        }
        
        // Clear only the visuals (not the state)
        function clearSinglePOCVisuals() {
            Object.values(singlePocLines).forEach(l => map.removeLayer(l));
            Object.values(singlePocMarkers).forEach(m => map.removeLayer(m));
            singlePocLines = {};
            singlePocMarkers = {};
            
            // Remove pin marker
            if (singlePocClickPin) {
                map.removeLayer(singlePocClickPin);
                singlePocClickPin = null;
            }
            
            // Hide floating panel
            const panel = document.getElementById('poc-float-panel');
            if (panel) {
                panel.classList.remove('visible');
            }
        }
        
        // ============== SITE FUNCTIONS ==============
        
        // Generate unique ID
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }
        
        // Load sites from localStorage
        function loadSitesFromStorage() {
            try {
                const stored = localStorage.getItem('poc-finder-sites');
                if (stored) {
                    sites = JSON.parse(stored);
                }
            } catch (e) {
                console.error('Failed to load sites from storage:', e);
                sites = [];
            }
        }
        
        // Save sites to localStorage
        function saveSitesToStorage() {
            try {
                localStorage.setItem('poc-finder-sites', JSON.stringify(sites));
            } catch (e) {
                console.error('Failed to save sites to storage:', e);
            }
        }
        
        // Create site marker
        function createSiteMarker(site) {
            const icon = L.divIcon({
                className: '',
                html: '<div class="site-marker-icon"></div>',
                iconSize: [24, 32],
                iconAnchor: [12, 32]  // Bottom center of pin
            });
            
            const marker = L.marker([site.lat, site.lng], { icon })
                .bindPopup(`<strong>${site.name}</strong><br>Click to view POCs`)
                .on('click', () => selectSite(site.id));
            
            return marker;
        }
        
        // Select a site
        function selectSite(siteId) {
            currentSiteId = siteId;
            const site = sites.find(s => s.id === siteId);
            
            if (!site) return;
            
            // Clear previous POC markers and lines
            clearPOCVisuals();
            
            // Create site marker if not exists
            if (!siteMarkers[siteId]) {
                siteMarkers[siteId] = createSiteMarker(site);
            }
            siteMarkers[siteId].addTo(map);
            
            // Pan to site
            map.setView([site.lat, site.lng], Math.max(map.getZoom(), 12));
            
            // Render side panel with site details
            renderSidePanel();
            
            // Draw POC markers and lines
            drawPOCVisuals(site);
        }
        
        // ============== OBSTACLE & CROSSING DETECTION ==============
        
        // Obstacle type colors
        const OBSTACLE_COLORS = {
            road: '#f59e0b',      // Orange
            railway: '#8b5cf6',   // Purple
            waterway: '#3b82f6',  // Blue
            builtup: 'rgba(168, 85, 247, 0.25)'  // Semi-transparent purple-red
        };
        
        // Tolerance in meters for near-miss detection
        const OBSTACLE_TOLERANCE_METERS = 3;
        
        // Helper: Get the bearing (direction in degrees) of a line at the point nearest to a given location.
        // Used to determine if two lines are running parallel vs crossing each other.
        function getLineBearingAtPoint(line, point) {
            const nearest = turf.nearestPointOnLine(line, point, { units: 'meters' });
            const segIdx = nearest.properties.index;
            const coords = line.geometry.coordinates;
            
            if (segIdx !== undefined && segIdx < coords.length - 1) {
                return turf.bearing(turf.point(coords[segIdx]), turf.point(coords[segIdx + 1]));
            } else if (coords.length >= 2) {
                return turf.bearing(
                    turf.point(coords[coords.length - 2]),
                    turf.point(coords[coords.length - 1])
                );
            }
            return null;
        }
        
        // Helper: Check if two bearings are nearly parallel (within threshold degrees).
        // Since roads are bidirectional, 0 and 180 are considered parallel.
        function areBearingsParallel(bearing1, bearing2, thresholdDeg) {
            if (bearing1 === null || bearing2 === null) return false;
            thresholdDeg = thresholdDeg || 25;
            
            let diff = Math.abs(bearing1 - bearing2) % 360;
            if (diff > 180) diff = 360 - diff;
            // Treat opposite directions as parallel (e.g. 10 vs 190)
            if (diff > 90) diff = 180 - diff;
            
            return diff <= thresholdDeg;
        }
        
        // Helper: Check if two lines intersect or come within tolerance distance
        function linesIntersectOrNear(line1, line2, toleranceMeters) {
            // First check exact intersection
            const exactIntersections = turf.lineIntersect(line1, line2);
            if (exactIntersections.features.length > 0) {
                return { intersects: true, points: exactIntersections.features };
            }
            
            // Check for near-misses by sampling points along line1 and checking distance to line2
            const line1Length = turf.length(line1, { units: 'meters' });
            const numSamples = Math.max(10, Math.ceil(line1Length / 20)); // Sample every ~20m
            
            for (let i = 0; i <= numSamples; i++) {
                const fraction = i / numSamples;
                const pointOnLine1 = turf.along(line1, fraction * line1Length, { units: 'meters' });
                const nearestOnLine2 = turf.nearestPointOnLine(line2, pointOnLine1, { units: 'meters' });
                
                if (nearestOnLine2.properties.dist !== undefined && 
                    nearestOnLine2.properties.dist <= toleranceMeters) {
                    // Found a near-miss, return the nearest point as intersection
                    return { 
                        intersects: true, 
                        points: [{ geometry: { coordinates: nearestOnLine2.geometry.coordinates } }],
                        nearMiss: true
                    };
                }
            }
            
            // Also check points along line2 against line1 (for short segments)
            const line2Length = turf.length(line2, { units: 'meters' });
            const numSamples2 = Math.max(5, Math.ceil(line2Length / 30));
            
            for (let i = 0; i <= numSamples2; i++) {
                const fraction = i / numSamples2;
                const pointOnLine2 = turf.along(line2, fraction * line2Length, { units: 'meters' });
                const nearestOnLine1 = turf.nearestPointOnLine(line1, pointOnLine2, { units: 'meters' });
                
                if (nearestOnLine1.properties.dist !== undefined && 
                    nearestOnLine1.properties.dist <= toleranceMeters) {
                    return { 
                        intersects: true, 
                        points: [{ geometry: { coordinates: pointOnLine2.geometry.coordinates } }],
                        nearMiss: true
                    };
                }
            }
            
            return { intersects: false, points: [] };
        }
        
        // Helper: Check if a line intersects or passes through a polygon (with tolerance)
        function lineIntersectsPolygon(line, polygon, toleranceMeters) {
            const lineCoords = line.geometry.coordinates;
            const startPoint = turf.point(lineCoords[0]);
            const endPoint = turf.point(lineCoords[lineCoords.length - 1]);
            
            // Check if either endpoint is inside the polygon
            if (turf.booleanPointInPolygon(startPoint, polygon) || 
                turf.booleanPointInPolygon(endPoint, polygon)) {
                // Find centroid of polygon as the "crossing" point
                const centroid = turf.centroid(polygon);
                return { 
                    intersects: true, 
                    points: [{ geometry: { coordinates: centroid.geometry.coordinates } }],
                    containsEndpoint: true
                };
            }
            
            // Check for line intersection with polygon boundary
            const polygonLine = turf.polygonToLine(polygon);
            const intersection = turf.lineIntersect(line, polygonLine);
            if (intersection.features.length > 0) {
                return { intersects: true, points: intersection.features };
            }
            
            // Check if line crosses through polygon interior
            if (turf.booleanCrosses(line, polygon)) {
                const centroid = turf.centroid(polygon);
                return { 
                    intersects: true, 
                    points: [{ geometry: { coordinates: centroid.geometry.coordinates } }]
                };
            }
            
            // Check for near-misses (line passes very close to polygon)
            // Sample points along the line and check distance to polygon
            const lineLength = turf.length(line, { units: 'meters' });
            const numSamples = Math.max(10, Math.ceil(lineLength / 15));
            
            for (let i = 0; i <= numSamples; i++) {
                const fraction = i / numSamples;
                const pointOnLine = turf.along(line, fraction * lineLength, { units: 'meters' });
                
                // Check if point is inside or very close to polygon
                if (turf.booleanPointInPolygon(pointOnLine, polygon)) {
                    return { 
                        intersects: true, 
                        points: [{ geometry: { coordinates: pointOnLine.geometry.coordinates } }],
                        nearMiss: true
                    };
                }
                
                // Check distance to polygon boundary
                const nearestOnBoundary = turf.nearestPointOnLine(polygonLine, pointOnLine, { units: 'meters' });
                if (nearestOnBoundary.properties.dist !== undefined && 
                    nearestOnBoundary.properties.dist <= toleranceMeters) {
                    return { 
                        intersects: true, 
                        points: [{ geometry: { coordinates: nearestOnBoundary.geometry.coordinates } }],
                        nearMiss: true
                    };
                }
            }
            
            return { intersects: false, points: [] };
        }
        
        // Helper: Validate and sanitize coordinates
        function sanitizeCoords(coords) {
            return coords.filter(coord => {
                if (!Array.isArray(coord) || coord.length < 2) return false;
                const [lng, lat] = coord;
                return typeof lng === 'number' && typeof lat === 'number' &&
                       !isNaN(lng) && !isNaN(lat) &&
                       lng >= -180 && lng <= 180 && lat >= -90 && lat <= 90;
            });
        }
        
        // Detect all obstacles for a POC connection line
        async function detectObstacles(site, poc) {
            // Check cache first - only return if fully fetched (not just loading)
            if (obstaclesCache[poc.id]?.fetched) {
                return obstaclesCache[poc.id].crossings;
            }
            
            try {
                // Build path from waypoints or simple start->end
                let pathCoords;
                if (poc.waypoints && poc.waypoints.length > 0) {
                    pathCoords = [
                        [site.lng, site.lat],
                        ...poc.waypoints.map(wp => [wp.lng, wp.lat]),
                        [poc.lng, poc.lat]
                    ];
                } else {
                    pathCoords = [
                        [site.lng, site.lat],
                        [poc.lng, poc.lat]
                    ];
                }
                
                // Sanitize coordinates
                pathCoords = sanitizeCoords(pathCoords);
                if (pathCoords.length < 2) {
                    console.warn('Invalid path coordinates for obstacle detection');
                    obstaclesCache[poc.id] = { crossings: [], builtupAreas: [], fetched: true };
                    return [];
                }
                
                // Create the connection line from all waypoints
                const connectionLine = turf.lineString(pathCoords);
                
                // Calculate bounding box with padding
                const bbox = turf.bbox(connectionLine);
                const padding = 0.005;  // ~500m padding
                const paddedBbox = [
                    bbox[0] - padding,  // minLng
                    bbox[1] - padding,  // minLat
                    bbox[2] + padding,  // maxLng
                    bbox[3] + padding   // maxLat
                ];
                
                // Build Overpass API query for roads, railways, waterways, and buildings
                // Include all drivable surfaces: roads, tracks, service roads, etc.
                // Only exclude pedestrian-only paths: footway, cycleway, bridleway, steps, pedestrian
                const query = `
                    [out:json][timeout:15];
                    (
                        way["highway"]["highway"!~"footway|cycleway|bridleway|steps|pedestrian|corridor"]
                            (${paddedBbox[1]},${paddedBbox[0]},${paddedBbox[3]},${paddedBbox[2]});
                        way["railway"="rail"]
                            (${paddedBbox[1]},${paddedBbox[0]},${paddedBbox[3]},${paddedBbox[2]});
                        way["waterway"~"river|canal"]
                            (${paddedBbox[1]},${paddedBbox[0]},${paddedBbox[3]},${paddedBbox[2]});
                        way["building"]
                            (${paddedBbox[1]},${paddedBbox[0]},${paddedBbox[3]},${paddedBbox[2]});
                    );
                    out geom;
                `;
                
                // Fetch from Overpass API
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                
                if (!response.ok) {
                    throw new Error(`Overpass API error: ${response.status}`);
                }
                
                const data = await response.json();
                const crossings = [];
                const builtupAreas = [];  // Store polygons for overlay
                
                // Track already-detected obstacles to avoid duplicates
                const detectedObstacles = new Set();
                
                // Process each element
                data.elements.forEach(element => {
                    if (!element.geometry && !element.members) return;
                    
                    const tags = element.tags || {};
                    
                    // Determine obstacle type
                    let obstacleType = null;
                    let obstacleName = 'Unknown';
                    
                    if (tags.highway) {
                        obstacleType = 'road';
                        obstacleName = tags.name || `${tags.highway} road`;
                    } else if (tags.railway) {
                        obstacleType = 'railway';
                        obstacleName = tags.name || 'Railway';
                    } else if (tags.waterway) {
                        obstacleType = 'waterway';
                        obstacleName = tags.name || `${tags.waterway}`;
                    } else if (tags.building) {
                        obstacleType = 'building';
                        obstacleName = tags.name || 'Building';
                    }
                    
                    if (!obstacleType) return;
                    
                    // Handle ways (lines or polygons)
                    if (element.type === 'way' && element.geometry) {
                        let coords = element.geometry.map(pt => [pt.lon, pt.lat]);
                        coords = sanitizeCoords(coords);
                        if (coords.length < 2) return;
                        
                        // Create unique key to avoid duplicates
                        const obstacleKey = `${element.id}-${obstacleType}`;
                        if (detectedObstacles.has(obstacleKey)) return;
                        
                        if (obstacleType === 'building') {
                            // For buildings, check if line passes through polygon
                            if (coords.length >= 3) {
                                // Close the polygon if needed
                                const polyCoords = [...coords];
                                if (polyCoords[0][0] !== polyCoords[polyCoords.length-1][0] || 
                                    polyCoords[0][1] !== polyCoords[polyCoords.length-1][1]) {
                                    polyCoords.push(polyCoords[0]);
                                }
                                
                                // Need at least 4 points for a valid polygon (3 vertices + closing point)
                                if (polyCoords.length < 4) return;
                                
                                try {
                                    const polygon = turf.polygon([polyCoords]);
                                    
                                    // Use robust intersection check
                                    const result = lineIntersectsPolygon(connectionLine, polygon, OBSTACLE_TOLERANCE_METERS);
                                    
                                    if (result.intersects) {
                                        detectedObstacles.add(obstacleKey);
                                        
                                        // Store polygon for overlay
                                        builtupAreas.push({
                                            coords: polyCoords,
                                            name: obstacleName,
                                            type: tags.building
                                        });
                                        
                                        // Add crossing point
                                        if (result.points.length > 0) {
                                            const pt = result.points[0].geometry.coordinates;
                                            crossings.push({
                                                lat: pt[1],
                                                lng: pt[0],
                                                obstacleName: obstacleName,
                                                obstacleType: obstacleType,
                                                subType: tags.building,
                                                nearMiss: result.nearMiss || false
                                            });
                                        }
                                    }
                                } catch (e) {
                                    // Invalid polygon geometry - log and skip
                                    console.warn(`Invalid building polygon (element ${element.id}):`, e.message);
                                }
                            }
                        } else {
                            // For linear features (roads, railways, waterways)
                            try {
                                const featureLine = turf.lineString(coords);
                                
                                // Use robust intersection check with tolerance
                                const result = linesIntersectOrNear(connectionLine, featureLine, OBSTACLE_TOLERANCE_METERS);
                                
                                if (result.intersects) {
                                    // Filter crossing points: for roads, skip points where the
                                    // connection line runs parallel to the road (i.e. the route
                                    // follows this road rather than crossing it).
                                    const validCrossings = [];
                                    
                                    result.points.forEach(intersection => {
                                        const pt = intersection.geometry.coordinates;
                                        
                                        if (obstacleType === 'road') {
                                            const iPt = turf.point(pt);
                                            const connBearing = getLineBearingAtPoint(connectionLine, iPt);
                                            const roadBearing = getLineBearingAtPoint(featureLine, iPt);
                                            
                                            if (areBearingsParallel(connBearing, roadBearing)) {
                                                // Route runs along this road  not a true crossing
                                                return;
                                            }
                                        }
                                        
                                        validCrossings.push({
                                            lat: pt[1],
                                            lng: pt[0],
                                            obstacleName: obstacleName,
                                            obstacleType: obstacleType,
                                            subType: tags.highway || tags.railway || tags.waterway,
                                            nearMiss: result.nearMiss || false
                                        });
                                    });
                                    
                                    if (validCrossings.length > 0) {
                                        detectedObstacles.add(obstacleKey);
                                        crossings.push(...validCrossings);
                                    }
                                }
                            } catch (e) {
                                // Invalid line geometry - log and skip
                                console.warn(`Invalid linear feature (element ${element.id}):`, e.message);
                            }
                        }
                    }
                });
                
                // Cache the results
                obstaclesCache[poc.id] = {
                    crossings: crossings,
                    builtupAreas: builtupAreas,
                    fetched: true
                };
                
                return crossings;
                
            } catch (error) {
                console.error('Obstacle detection failed:', error);
                // Cache empty result to avoid repeated failed requests
                obstaclesCache[poc.id] = {
                    crossings: [],
                    builtupAreas: [],
                    fetched: true,
                    error: true
                };
                return [];
            }
        }
        
        
        // ============== END OBSTACLE & CROSSING DETECTION ==============
        
        // Clear all POC markers and lines from map
        function clearPOCVisuals() {
            Object.values(pocMarkers).forEach(m => map.removeLayer(m));
            Object.values(pocLines).forEach(l => map.removeLayer(l));
            // Clear waypoint markers
            Object.values(pocWaypointMarkers).forEach(markers => {
                markers.forEach(m => map.removeLayer(m));
            });
            // Clear road crossing markers
            Object.values(obstacleCrossingMarkers).forEach(markers => {
                markers.forEach(m => map.removeLayer(m));
            });
            // Clear obstacle overlays
            Object.values(obstacleOverlays).forEach(overlays => {
                overlays.forEach(o => map.removeLayer(o));
            });
            // Clear routed paths
            clearAllRoutedPaths();
            
            pocMarkers = {};
            pocLines = {};
            pocWaypointMarkers = {};
            obstacleCrossingMarkers = {};
            obstacleOverlays = {};
        }
        
        // Clear obstacles for a specific POC
        function clearPOCObstacles(pocId) {
            // Clear road crossing markers for this POC
            if (obstacleCrossingMarkers[pocId]) {
                obstacleCrossingMarkers[pocId].forEach(m => map.removeLayer(m));
                delete obstacleCrossingMarkers[pocId];
            }
            // Clear obstacle overlays for this POC
            if (obstacleOverlays[pocId]) {
                obstacleOverlays[pocId].forEach(o => map.removeLayer(o));
                delete obstacleOverlays[pocId];
            }
            // Clear cache for this POC
            delete obstaclesCache[pocId];
        }
        
        // Storage for POC waypoint markers
        let pocWaypointMarkers = {};
        
        // Calculate total path distance from waypoints
        function calculatePathDistance(site, poc) {
            const points = [
                [site.lng, site.lat],
                ...(poc.waypoints || []).map(wp => [wp.lng, wp.lat]),
                [poc.lng, poc.lat]
            ];
            
            let totalDistance = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const from = turf.point(points[i]);
                const to = turf.point(points[i + 1]);
                totalDistance += turf.distance(from, to, { units: 'meters' });
            }
            return totalDistance;
        }
        
        // Get full path including waypoints
        function getFullPath(site, poc) {
            return [
                [site.lat, site.lng],
                ...(poc.waypoints || []).map(wp => [wp.lat, wp.lng]),
                [poc.lat, poc.lng]
            ];
        }
        
        // Rebuild line and waypoint markers for a POC
        function rebuildPOCLine(site, poc) {
            const color = poc.color || '#6b7280';
            const line = pocLines[poc.id];
            
            if (!line) return;
            
            // Update line path
            line.setLatLngs(getFullPath(site, poc));
            
            // Clear existing waypoint markers
            if (pocWaypointMarkers[poc.id]) {
                pocWaypointMarkers[poc.id].forEach(m => map.removeLayer(m));
            }
            pocWaypointMarkers[poc.id] = [];
            
            // Create waypoint markers
            (poc.waypoints || []).forEach((wp, index) => {
                const wpMarker = L.marker([wp.lat, wp.lng], {
                    draggable: true,
                    icon: L.divIcon({
                        className: '',
                        html: `<div style="
                            width: 12px;
                            height: 12px;
                            border-radius: 50%;
                            background: white;
                            border: 2px solid ${color};
                            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                            cursor: grab;
                        "></div>`,
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    })
                }).addTo(map);
                
                // Drag to move waypoint
                wpMarker.on('drag', function(e) {
                    poc.waypoints[index] = { lat: e.target.getLatLng().lat, lng: e.target.getLatLng().lng };
                    line.setLatLngs(getFullPath(site, poc));
                });
                
                wpMarker.on('dragend', function() {
                    // Recalculate distance and obstacles
                    poc.distance = calculatePathDistance(site, poc);
                    recalculatePOCObstacles(site, poc);
                });
                
                // Double-click to remove waypoint
                wpMarker.on('dblclick', function(e) {
                    L.DomEvent.stopPropagation(e);
                    poc.waypoints.splice(index, 1);
                    poc.distance = calculatePathDistance(site, poc);
                    rebuildPOCLine(site, poc);
                    recalculatePOCObstacles(site, poc);
                });
                
                wpMarker.bindTooltip('Drag to move, double-click to remove', { direction: 'top', offset: [0, -5] });
                
                pocWaypointMarkers[poc.id].push(wpMarker);
            });
        }
        
        // Storage for routed paths (separate from manual waypoints)
        let routedPaths = {};  // Map of POC ID to { coordinates: [[lat, lng], ...], distance: meters }
        let routedPathLines = {};  // Map of POC ID to Leaflet polyline(s)
        let routeWaypointMarkers = {};  // Map of POC ID to array of via waypoint markers
        
        // Calculate distance between two points using turf
        function calculateStraightLineDistance(lat1, lng1, lat2, lng2) {
            const from = turf.point([lng1, lat1]);
            const to = turf.point([lng2, lat2]);
            return turf.distance(from, to, { units: 'meters' });
        }
        
        // Calculate route along public roads using OSRM with foot profile
        // Uses walking navigation to avoid one-way street issues (no U-turns),
        // producing routes that follow the most direct path along public roads -
        // ideal for cable routing where traffic direction doesn't matter
        async function calculateRoadRoute(pocId) {
            const site = sites.find(s => s.id === currentSiteId);
            if (!site) return;
            
            const poc = site.pocs.find(p => p.id === pocId);
            if (!poc) return;
            
            // Set loading state
            poc.routeLoading = true;
            renderSidePanel();
            
            try {
                // Build waypoints string: start to end
                const waypointsStr = `${site.lng},${site.lat};${poc.lng},${poc.lat}`;
                
                // Use OSRM public server with foot profile
                // Foot profile ignores one-way restrictions and produces more direct routes
                // along roads, which better represents how cables would actually be laid
                const response = await fetch(
                    `https://router.project-osrm.org/route/v1/foot/${waypointsStr}?overview=full&geometries=geojson`,
                    { headers: { 'User-Agent': 'POC-Finder-App' } }
                );
                
                if (!response.ok) {
                    throw new Error('Routing service unavailable');
                }
                
                const data = await response.json();
                
                if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
                    throw new Error('No route found');
                }
                
                const route = data.routes[0];
                let routeCoords = route.geometry.coordinates.map(coord => [coord[1], coord[0]]); // [lat, lng]
                let roadDistance = route.distance; // in meters
                
                // Get the snapped waypoints from OSRM (where the route actually starts/ends on the road)
                const waypoints = data.waypoints || [];
                const routeStart = waypoints[0]?.location; // [lng, lat]
                let routeEnd = waypoints[waypoints.length - 1]?.location; // [lng, lat]
                
                // --- Optimize POC: find nearer cable of same voltage along the route ---
                // The initial POC was found by straight-line distance, but the road route
                // may pass closer to a different segment of cable at the same voltage.
                // Scan along the route and find the point where the road is nearest to any
                // cable of the same voltage, then re-target the POC there if it shortens
                // the total path (road distance + off-road extension to cable).
                {
                    const routeLine = turf.lineString(route.geometry.coordinates); // GeoJSON [lng, lat]
                    const routeLengthM = turf.length(routeLine, { units: 'meters' });
                    const pocVoltage = poc.voltage;
                    
                    // Collect cable line features of the same voltage, pre-filtered by route bbox
                    const routeBbox = turf.bbox(routeLine);
                    const searchPadding = 0.009; // ~1km in degrees
                    const expandedBbox = [
                        routeBbox[0] - searchPadding,
                        routeBbox[1] - searchPadding,
                        routeBbox[2] + searchPadding,
                        routeBbox[3] + searchPadding
                    ];
                    
                    const candidateLines = []; // Turf lineString features near the route
                    
                    Object.keys(rawGeoJSONData).forEach(layerName => {
                        if (extractVoltage(layerName) !== pocVoltage) return;
                        const geoJSON = rawGeoJSONData[layerName];
                        if (!geoJSON || !geoJSON.features) return;
                        
                        geoJSON.features.forEach(feature => {
                            if (!feature.geometry) return;
                            
                            // Bbox pre-filter: skip features far from the route
                            try {
                                const fBbox = turf.bbox(feature);
                                if (fBbox[0] > expandedBbox[2] || fBbox[2] < expandedBbox[0] ||
                                    fBbox[1] > expandedBbox[3] || fBbox[3] < expandedBbox[1]) {
                                    return;
                                }
                            } catch (e) { return; }
                            
                            try {
                                if (feature.geometry.type === 'LineString') {
                                    candidateLines.push(feature);
                                } else if (feature.geometry.type === 'MultiLineString') {
                                    feature.geometry.coordinates.forEach(coords => {
                                        try { candidateLines.push(turf.lineString(coords)); } catch (e) {}
                                    });
                                }
                            } catch (e) {}
                        });
                    });
                    
                    if (candidateLines.length > 0 && routeLengthM > 0) {
                        // Sample along the route at ~50m intervals to find optimal cable connection
                        const numSamples = Math.min(500, Math.max(20, Math.ceil(routeLengthM / 50)));
                        const sampleInterval = routeLengthM / numSamples;
                        
                        let bestTotalDist = Infinity;
                        let bestCablePoint = null;
                        let bestDistAlongRoute = null;
                        
                        for (let d = 0; d <= routeLengthM; d += sampleInterval) {
                            const routePoint = turf.along(routeLine, d, { units: 'meters' });
                            
                            let nearestCableDist = Infinity;
                            let nearestCablePt = null;
                            
                            candidateLines.forEach(line => {
                                try {
                                    const nearest = turf.nearestPointOnLine(line, routePoint, { units: 'meters' });
                                    if (nearest.properties.dist < nearestCableDist) {
                                        nearestCableDist = nearest.properties.dist;
                                        nearestCablePt = {
                                            lat: nearest.geometry.coordinates[1],
                                            lng: nearest.geometry.coordinates[0]
                                        };
                                    }
                                } catch (e) {}
                            });
                            
                            if (nearestCablePt && nearestCableDist <= 1000) { // Max 1km off-road to cable
                                const totalDist = d + nearestCableDist;
                                if (totalDist < bestTotalDist) {
                                    bestTotalDist = totalDist;
                                    bestCablePoint = nearestCablePt;
                                    bestDistAlongRoute = d;
                                }
                            }
                        }
                        
                        // Calculate original total distance for comparison
                        const origOffRoadDist = routeEnd ?
                            calculateStraightLineDistance(routeEnd[1], routeEnd[0], poc.lat, poc.lng) : 0;
                        const originalTotalDist = roadDistance + origOffRoadDist;
                        
                        // Use optimized POC if it provides a meaningfully shorter total path (>50m saving)
                        if (bestCablePoint && bestDistAlongRoute !== null && bestTotalDist < originalTotalDist - 50) {
                            console.log(`Route optimizer: Found nearer ${pocVoltage} POC at ${bestDistAlongRoute.toFixed(0)}m along route ` +
                                `(total: ${bestTotalDist.toFixed(0)}m vs original: ${originalTotalDist.toFixed(0)}m, ` +
                                `saving ${(originalTotalDist - bestTotalDist).toFixed(0)}m)`);
                            
                            // Update POC endpoint to the nearer cable point
                            poc.lat = bestCablePoint.lat;
                            poc.lng = bestCablePoint.lng;
                            
                            // Truncate the route at the optimal exit point on the road
                            if (bestDistAlongRoute < routeLengthM - 10) {
                                const truncPoint = turf.along(routeLine, bestDistAlongRoute, { units: 'meters' });
                                const truncated = turf.lineSlice(
                                    turf.point(route.geometry.coordinates[0]),
                                    truncPoint,
                                    routeLine
                                );
                                
                                routeCoords = truncated.geometry.coordinates.map(coord => [coord[1], coord[0]]);
                                roadDistance = bestDistAlongRoute;
                                
                                // Update routeEnd so the off-road extension below uses the new route endpoint
                                const lastCoord = truncated.geometry.coordinates[truncated.geometry.coordinates.length - 1];
                                routeEnd = lastCoord; // [lng, lat]
                            }
                            
                            // Try to snap optimized POC to a nearby pole/tower if poles layer is visible
                            if (polesTowersVisible) {
                                const nearestPole = findNearestPoleTower(poc.lat, poc.lng, pocVoltage, 200);
                                if (nearestPole) {
                                    poc.lat = nearestPole.lat;
                                    poc.lng = nearestPole.lng;
                                    poc.type = 'Pole/Tower';
                                    poc.poleInfo = nearestPole.properties;
                                    console.log('Route optimizer: Snapped optimized POC to nearby pole/tower');
                                }
                            }
                        }
                    }
                }
                
                // Build complete path with off-road extensions if needed
                let fullCoordinates = [];
                let totalDistance = roadDistance;
                let offRoadStartDist = 0;
                let offRoadEndDist = 0;
                
                // Check if site is off-road (route doesn't start at site location)
                if (routeStart) {
                    const siteToRoadStart = calculateStraightLineDistance(
                        site.lat, site.lng, 
                        routeStart[1], routeStart[0]
                    );
                    // If site is more than 10m from road start, add straight line connector
                    if (siteToRoadStart > 10) {
                        fullCoordinates.push([site.lat, site.lng]);
                        offRoadStartDist = siteToRoadStart;
                        totalDistance += siteToRoadStart;
                    }
                }
                
                // Add the road route coordinates
                fullCoordinates = fullCoordinates.concat(routeCoords);
                
                // Check if POC is off-road (route doesn't end at POC location)
                if (routeEnd) {
                    const roadEndToPOC = calculateStraightLineDistance(
                        routeEnd[1], routeEnd[0],
                        poc.lat, poc.lng
                    );
                    // If POC is more than 10m from road end, add straight line connector
                    if (roadEndToPOC > 10) {
                        fullCoordinates.push([poc.lat, poc.lng]);
                        offRoadEndDist = roadEndToPOC;
                        totalDistance += roadEndToPOC;
                    }
                }
                
                // Simplify the route to reduce waypoints while maintaining general shape
                // Uses Ramer-Douglas-Peucker algorithm via Turf.js
                // Tolerance of 0.00015 (~15m) provides good balance between accuracy and simplicity
                const originalPointCount = fullCoordinates.length;
                let simplifiedCoords = fullCoordinates;
                
                if (fullCoordinates.length > 3) {
                    // Convert to GeoJSON format for Turf (lng, lat)
                    const lineForSimplify = turf.lineString(
                        fullCoordinates.map(c => [c[1], c[0]])
                    );
                    
                    // Simplify with tolerance (in degrees, ~0.00015 = ~15 meters)
                    const simplified = turf.simplify(lineForSimplify, {
                        tolerance: 0.00015,
                        highQuality: true
                    });
                    
                    // Convert back to [lat, lng] format
                    simplifiedCoords = simplified.geometry.coordinates.map(c => [c[1], c[0]]);
                    
                    // Ensure we still have the exact start and end points
                    simplifiedCoords[0] = fullCoordinates[0];
                    simplifiedCoords[simplifiedCoords.length - 1] = fullCoordinates[fullCoordinates.length - 1];
                    
                    console.log(`Route simplified: ${originalPointCount} points  ${simplifiedCoords.length} points`);
                }
                
                // Convert simplified route coordinates to waypoints for the regular POC line system
                // Skip the first point (site) and last point (POC) as those are the endpoints
                // The simplifiedCoords are in [lat, lng] format
                const newWaypoints = [];
                for (let i = 1; i < simplifiedCoords.length - 1; i++) {
                    newWaypoints.push({
                        lat: simplifiedCoords[i][0],
                        lng: simplifiedCoords[i][1]
                    });
                }
                
                // Replace the POC's waypoints with the route waypoints
                poc.waypoints = newWaypoints;
                
                // Recalculate distance based on simplified path for accuracy
                poc.distance = calculatePathDistance(site, poc);
                
                // Clear any existing route-specific data (we're converting to regular line)
                delete poc.routedDistance;
                delete poc.routedPath;
                delete poc.roadDistance;
                delete poc.offRoadStartDist;
                delete poc.offRoadEndDist;
                delete poc.routeViaPoints;
                delete poc.routeAvoidMotorway;
                delete poc.routeAvoidToll;
                delete poc.routeAvoidFerry;
                delete routedPaths[pocId];
                
                // Remove any existing routed path visuals
                if (routedPathLines[pocId]) {
                    if (Array.isArray(routedPathLines[pocId])) {
                        routedPathLines[pocId].forEach(line => map.removeLayer(line));
                    } else {
                        map.removeLayer(routedPathLines[pocId]);
                    }
                    delete routedPathLines[pocId];
                }
                if (routeWaypointMarkers[pocId]) {
                    routeWaypointMarkers[pocId].forEach(m => map.removeLayer(m));
                    delete routeWaypointMarkers[pocId];
                }
                
                poc.routeLoading = false;
                
                saveSitesToStorage();
                
                // Rebuild the regular POC line with the new waypoints
                rebuildPOCLine(site, poc);
                
                // Move the POC endpoint marker to match the (possibly optimized) POC location
                if (pocMarkers[pocId]) {
                    pocMarkers[pocId].setLatLng([poc.lat, poc.lng]);
                }
                
                // Recalculate obstacles for the new path
                recalculatePOCObstacles(site, poc);
                
                // Update side panel
                renderSidePanel();
                
            } catch (error) {
                console.error('Error calculating route:', error);
                poc.routeLoading = false;
                poc.routeError = error.message;
                renderSidePanel();
                
                // Show user-friendly error
                alert(`Could not calculate route: ${error.message}. The routing service may be temporarily unavailable.`);
            }
        }
        
        // Clear all routed path visuals
        function clearAllRoutedPaths() {
            Object.values(routedPathLines).forEach(lineOrLines => {
                if (Array.isArray(lineOrLines)) {
                    lineOrLines.forEach(line => map.removeLayer(line));
                } else {
                    map.removeLayer(lineOrLines);
                }
            });
            routedPathLines = {};
            
            // Clear all waypoint markers
            Object.values(routeWaypointMarkers).forEach(markers => {
                markers.forEach(m => map.removeLayer(m));
            });
            routeWaypointMarkers = {};
        }
        
        // Check obstacles for a POC on demand (triggered by button click)
        function checkPOCObstacles(pocId) {
            const site = sites.find(s => s.id === currentSiteId);
            if (!site) return;
            
            const poc = site.pocs.find(p => p.id === pocId);
            if (!poc) return;
            
            // Set loading state
            obstaclesCache[pocId] = { loading: true, fetched: false, crossings: [], builtupAreas: [] };
            renderSidePanel();
            
            detectObstacles(site, poc).then(crossings => {
                const cacheData = obstaclesCache[pocId];
                cacheData.loading = false;
                cacheData.fetched = true;
                
                saveSitesToStorage();
                
                // Draw obstacles on map
                drawObstacleVisualsForPOC(poc, cacheData, crossings);
                
                // Update side panel
                renderSidePanel();
            }).catch(err => {
                console.error('Error checking obstacles:', err);
                const cacheData = obstaclesCache[pocId];
                cacheData.loading = false;
                cacheData.fetched = true;
                renderSidePanel();
            });
        }
        
        // Recalculate obstacles after path change (only if already checked)
        function recalculatePOCObstacles(site, poc) {
            // Only recalculate if obstacles were already checked
            if (!obstaclesCache[poc.id]?.fetched) return;
            
            clearPOCObstacles(poc.id);
            
            // Set loading state
            obstaclesCache[poc.id] = { loading: true, fetched: false, crossings: [], builtupAreas: [] };
            renderSidePanel();
            
            detectObstacles(site, poc).then(crossings => {
                const cacheData = obstaclesCache[poc.id];
                cacheData.loading = false;
                cacheData.fetched = true;
                
                saveSitesToStorage();
                
                // Draw obstacles
                drawObstacleVisualsForPOC(poc, cacheData, crossings);
                
                // Update side panel
                renderSidePanel();
            }).catch(err => {
                console.error('Error recalculating obstacles:', err);
                const cacheData = obstaclesCache[poc.id];
                cacheData.loading = false;
                cacheData.fetched = true;
                renderSidePanel();
            });
        }
        
        // Draw obstacle visuals for a POC
        function drawObstacleVisualsForPOC(poc, cacheData, crossings) {
            // Draw built-up area overlays
            if (cacheData?.builtupAreas?.length > 0) {
                obstacleOverlays[poc.id] = [];
                
                cacheData.builtupAreas.forEach(area => {
                    const polygon = L.polygon(
                        area.coords.map(c => [c[1], c[0]]),
                        {
                            color: 'rgba(168, 85, 247, 0.6)',
                            fillColor: 'rgba(168, 85, 247, 0.25)',
                            fillOpacity: 0.25,
                            weight: 1
                        }
                    ).addTo(map);
                    
                    polygon.bindPopup(`
                        <strong>Building</strong><br>
                        ${area.name}<br>
                        <em>${area.type}</em>
                    `);
                    
                    obstacleOverlays[poc.id].push(polygon);
                });
            }
            
            // Draw crossing markers
            if (crossings.length > 0) {
                obstacleCrossingMarkers[poc.id] = [];
                
                crossings.forEach(crossing => {
                    const crossingMarker = L.marker([crossing.lat, crossing.lng], {
                        icon: L.divIcon({
                            className: '',
                            html: `<div class="obstacle-crossing-marker"></div>`,
                            iconSize: [8, 8],
                            iconAnchor: [4, 4]
                        })
                    }).addTo(map);
                    
                    const typeLabel = crossing.obstacleType === 'road' ? 'Road' :
                                     crossing.obstacleType === 'railway' ? 'Railway' :
                                     crossing.obstacleType === 'waterway' ? 'Waterway' :
                                     crossing.obstacleType === 'building' ? 'Building' : 'Obstacle';
                    
                    crossingMarker.bindPopup(`
                        <strong>${typeLabel} Crossing</strong><br>
                        ${crossing.obstacleName}<br>
                        <em>${crossing.subType}</em>
                    `);
                    
                    obstacleCrossingMarkers[poc.id].push(crossingMarker);
                });
            }
        }
        
        // Draw POC markers and connection lines
        function drawPOCVisuals(site) {
            site.pocs.forEach(poc => {
                const color = poc.color || '#6b7280';
                
                // Initialize waypoints array if not present
                if (!poc.waypoints) {
                    poc.waypoints = [];
                }
                
                // Connection line with all waypoints
                const line = L.polyline(getFullPath(site, poc), {
                    color: color,
                    weight: 3,
                    dashArray: '8, 8',
                    opacity: 0.8
                }).addTo(map);
                pocLines[poc.id] = line;
                
                // Click on line to add waypoint
                line.on('click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    
                    // Find which segment was clicked and insert waypoint there
                    const clickPoint = [e.latlng.lng, e.latlng.lat];
                    const path = getFullPath(site, poc);
                    
                    let bestSegmentIndex = 0;
                    let minDistance = Infinity;
                    
                    for (let i = 0; i < path.length - 1; i++) {
                        const segmentLine = turf.lineString([
                            [path[i][1], path[i][0]],
                            [path[i+1][1], path[i+1][0]]
                        ]);
                        const nearest = turf.nearestPointOnLine(segmentLine, turf.point(clickPoint));
                        if (nearest.properties.dist < minDistance) {
                            minDistance = nearest.properties.dist;
                            bestSegmentIndex = i;
                        }
                    }
                    
                    // Insert new waypoint at the clicked position
                    const newWaypoint = { lat: e.latlng.lat, lng: e.latlng.lng };
                    poc.waypoints.splice(bestSegmentIndex, 0, newWaypoint);
                    
                    // Recalculate distance
                    poc.distance = calculatePathDistance(site, poc);
                    
                    // Rebuild line and markers
                    rebuildPOCLine(site, poc);
                    recalculatePOCObstacles(site, poc);
                });
                
                // Add tooltip to line
                line.bindTooltip('Click to add waypoint', { sticky: true });
                
                // POC endpoint marker - draggable
                const marker = L.marker([poc.lat, poc.lng], {
                    draggable: true,
                    icon: L.divIcon({
                        className: '',
                        html: `<div style="
                            width: 20px;
                            height: 20px;
                            border-radius: 50%;
                            background: ${color};
                            border: 3px solid white;
                            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                            cursor: grab;
                        "></div>`,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    })
                }).addTo(map);
                
                // Update popup content function
                const updatePopup = () => {
                    marker.bindPopup(`
                        <strong>${poc.voltage}</strong><br>
                        ${poc.type}<br>
                        ${formatDistance(poc.distance)}<br>
                        <em>${poc.powerMin} - ${poc.powerMax} MVA</em><br>
                        <small style="color:#6b7280;">Drag endpoint to adjust</small>
                    `);
                };
                updatePopup();
                pocMarkers[poc.id] = marker;
                
                // Drag event handlers for endpoint
                marker.on('drag', function(e) {
                    const newLatLng = e.target.getLatLng();
                    poc.lat = newLatLng.lat;
                    poc.lng = newLatLng.lng;
                    line.setLatLngs(getFullPath(site, poc));
                });
                
                marker.on('dragend', function(e) {
                    // Snap to nearest cable of the same voltage
                    const draggedLatLng = e.target.getLatLng();
                    const snappedPoint = findNearestCablePoint(draggedLatLng.lat, draggedLatLng.lng, poc.voltage, poc.layerName);
                    
                    if (snappedPoint) {
                        poc.lat = snappedPoint.lat;
                        poc.lng = snappedPoint.lng;
                        marker.setLatLng([snappedPoint.lat, snappedPoint.lng]);
                        line.setLatLngs(getFullPath(site, poc));
                    }
                    
                    poc.distance = calculatePathDistance(site, poc);
                    saveSitesToStorage();
                    updatePopup();
                    
                    // Only recalculate obstacles if they were already checked
                    recalculatePOCObstacles(site, poc);
                });
                
                // Create waypoint markers
                rebuildPOCLine(site, poc);
                
                // Draw any cached obstacle visuals (but don't auto-detect)
                if (obstaclesCache[poc.id]?.fetched) {
                    const cacheData = obstaclesCache[poc.id];
                    drawObstacleVisualsForPOC(poc, cacheData, cacheData.crossings || []);
                }
                
            });
        }
        
        // Update side panel visibility based on whether sites exist
        function updateSidePanelVisibility() {
            const panel = document.getElementById('side-panel');
            if (sites.length > 0) {
                panel.classList.add('visible');
            } else {
                panel.classList.remove('visible');
            }
        }
        
        // Deselect current site and show site list
        function deselectSite() {
            currentSiteId = null;
            addCustomPOCMode = false;
            document.getElementById('map').classList.remove('add-poc-mode-active');
            clearPOCVisuals();
            renderSidePanel();
        }
        
        // Site list filtering & sorting state
        let siteFilterText = '';
        let siteSortMode = 'name_asc'; // 'name_asc' | 'poc_desc' | 'voltage_desc'
        
        function handleSiteSearchChange(value) {
            siteFilterText = value || '';
            renderSidePanel();
        }
        
        function handleSiteSortChange(value) {
            siteSortMode = value || 'name_asc';
            renderSidePanel();
        }
        
        // Render side panel content - shows site list or site details
        function renderSidePanel() {
            const content = document.getElementById('side-panel-content');
            const header = document.querySelector('.side-panel-header h3');
            const closeBtn = document.querySelector('.side-panel-close');
            const site = sites.find(s => s.id === currentSiteId);
            
            updateSidePanelVisibility();
            
            if (!site) {
                // Show site list
                header.textContent = 'Sites';
                closeBtn.style.display = 'none';
                
                if (sites.length === 0) {
                    content.innerHTML = '<div class="poc-empty">No sites added yet</div>';
                    return;
                }
                
                // Apply search filter
                const filter = siteFilterText.trim().toLowerCase();
                let filteredSites = sites.filter(s => {
                    if (!filter) return true;
                    const nameMatch = s.name.toLowerCase().includes(filter);
                    const coordMatch = `${s.lat.toFixed(4)},${s.lng.toFixed(4)}`.includes(filter);
                    const voltageMatch = (s.pocs || []).some(p => p.voltage.toLowerCase().includes(filter));
                    return nameMatch || coordMatch || voltageMatch;
                });
                
                // Sort sites
                filteredSites = filteredSites.slice().sort((a, b) => {
                    if (siteSortMode === 'poc_desc') {
                        return (b.pocs?.length || 0) - (a.pocs?.length || 0);
                    }
                    if (siteSortMode === 'voltage_desc') {
                        const va = new Set((a.pocs || []).map(p => p.voltage)).size;
                        const vb = new Set((b.pocs || []).map(p => p.voltage)).size;
                        return vb - va;
                    }
                    // name_asc default
                    return a.name.localeCompare(b.name);
                });
                
                const siteListHTML = filteredSites.map(s => {
                    const voltages = [...new Set(s.pocs.map(p => p.voltage))];
                    const voltageTagsHTML = voltages.map(v => {
                        const color = VOLTAGE_POWER_RANGES[v]?.color || '#6b7280';
                        return `<span class="site-list-voltage-tag" style="background:${color}">${v}</span>`;
                    }).join('');
                    
                    return `
                        <div class="site-list-item" onclick="selectSite('${s.id}')">
                            <div class="site-list-item-name">${s.name}</div>
                            <div class="site-list-item-meta">
                                <span>${s.pocs.length} POC${s.pocs.length !== 1 ? 's' : ''}</span>
                                <span>${s.lat.toFixed(4)}, ${s.lng.toFixed(4)}</span>
                            </div>
                            ${voltageTagsHTML ? `<div class="site-list-item-voltages">${voltageTagsHTML}</div>` : ''}
                        </div>
                    `;
                }).join('');
                
                const controlsHTML = `
                    <div class="site-list-controls">
                        <div class="site-list-search">
                            <span style="font-size:11px;color:var(--color-muted);"></span>
                            <input
                                type="text"
                                id="site-search-input"
                                placeholder="Search by name, voltage, or coords"
                                value="${siteFilterText.replace(/"/g, '&quot;')}"
                                oninput="handleSiteSearchChange(this.value)"
                            />
                        </div>
                        <div class="site-list-sort">
                            <span>Sort by</span>
                            <select id="site-sort-select" onchange="handleSiteSortChange(this.value)">
                                <option value="name_asc"${siteSortMode === 'name_asc' ? ' selected' : ''}>Name (AZ)</option>
                                <option value="poc_desc"${siteSortMode === 'poc_desc' ? ' selected' : ''}>POC count</option>
                                <option value="voltage_desc"${siteSortMode === 'voltage_desc' ? ' selected' : ''}>Voltage diversity</option>
                            </select>
                        </div>
                    </div>
                `;
                
                content.innerHTML = controlsHTML + (siteListHTML || '<div class="poc-empty">No sites match your filters.</div>');
                return;
            }
            
            // Show site details
            header.textContent = 'Site Details';
            closeBtn.style.display = 'block';
            
            // POC cards
            const pocCardsHTML = site.pocs.map(poc => {
                const color = poc.color || '#6b7280';
                
                // Get obstacle crossings from cache
                const crossingData = obstaclesCache[poc.id];
                const crossings = crossingData?.crossings || [];
                const builtupAreas = crossingData?.builtupAreas || [];
                const isLoading = crossingData?.loading;
                const hasFetched = crossingData?.fetched;
                
                // Group crossings by type
                const roadCrossings = crossings.filter(c => c.obstacleType === 'road');
                const railwayCrossings = crossings.filter(c => c.obstacleType === 'railway');
                const waterwayCrossings = crossings.filter(c => c.obstacleType === 'waterway');
                
                const hasObstacles = crossings.length > 0 || builtupAreas.length > 0;
                
                // Build obstacle HTML - simplified to just counts
                let obstacleHTML = '';
                if (isLoading) {
                    obstacleHTML = '<div class="poc-obstacles-loading">Checking...</div>';
                } else if (hasFetched && hasObstacles) {
                    // Simple count summary
                    const counts = [];
                    if (roadCrossings.length > 0) counts.push(`${roadCrossings.length} road${roadCrossings.length > 1 ? 's' : ''}`);
                    if (railwayCrossings.length > 0) counts.push(`${railwayCrossings.length} railway${railwayCrossings.length > 1 ? 's' : ''}`);
                    if (waterwayCrossings.length > 0) counts.push(`${waterwayCrossings.length} waterway${waterwayCrossings.length > 1 ? 's' : ''}`);
                    if (builtupAreas.length > 0) counts.push(`${builtupAreas.length} building${builtupAreas.length > 1 ? 's' : ''}`);
                    
                    obstacleHTML = `<div class="poc-obstacles-summary warning"> ${counts.join(', ')}</div>`;
                } else if (hasFetched) {
                    obstacleHTML = '<div class="poc-obstacles-summary clear"> Route clear</div>';
                }
                
                // Show check obstacles button if not yet checked
                const checkObstaclesBtn = !hasFetched && !isLoading
                    ? `<button class="poc-action-btn" onclick="checkPOCObstacles('${poc.id}')">Check Obstacles</button>`
                    : '';
                
                // Route planning button - always available to (re)calculate road route
                const isRouteLoading = poc.routeLoading;
                const hasWaypoints = poc.waypoints && poc.waypoints.length > 0;
                let routeBtn = '';
                if (isRouteLoading) {
                    routeBtn = `<button class="poc-action-btn route" disabled>Planning...</button>`;
                } else {
                    const btnText = hasWaypoints ? 'Replan Route' : 'Plan Route';
                    routeBtn = `<button class="poc-action-btn route" onclick="calculateRoadRoute('${poc.id}')" title="Calculate cable route following public roads (replaces current waypoints)">${btnText}</button>`;
                }
                
                // Waypoints info
                let waypointsInfoHTML = '';
                if (hasWaypoints) {
                    waypointsInfoHTML = `<div class="poc-waypoints-info">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;flex-shrink:0;">
                            <path d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l5.447 2.724A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"/>
                        </svg>
                        <span>${poc.waypoints.length} waypoint${poc.waypoints.length > 1 ? 's' : ''}</span>
                    </div>`;
                }
                
                return `
                    <div class="poc-card${hasObstacles ? ' has-crossings' : ''}">
                        <div class="poc-card-header">
                            <div class="poc-voltage-badge" style="background: ${color}">${poc.voltage}</div>
                            <div class="poc-card-info">
                                <div class="poc-power-range">${poc.powerMin}  ${poc.powerMax} MVA</div>
                                <div class="poc-card-distance">${formatDistance(poc.distance)}${hasWaypoints ? ' (routed)' : ''}</div>
                                <div class="poc-card-type">${poc.type}${poc.isCustom ? ' <span class="poc-custom-badge">Custom</span>' : ''}</div>
                            </div>
                        </div>
                        ${waypointsInfoHTML}
                        ${obstacleHTML}
                        <div class="poc-card-actions">
                            ${routeBtn}
                            ${checkObstaclesBtn}
                            <button class="poc-action-btn reject" onclick="removePOC('${poc.id}')">Remove</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Parcel info display
            let parcelInfoHTML = '';
            if (site.parcelId || site.parcelArea) {
                const areaHectares = site.parcelArea ? (site.parcelArea / 10000).toFixed(2) : 'N/A';
                parcelInfoHTML = `
                    <div class="site-info-parcel" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.1); font-size: 11px; color: #6b7280;">
                        <div><strong>Parcel ID:</strong> ${site.parcelId || 'N/A'}</div>
                        <div><strong>Parcel Area:</strong> ${areaHectares} ha</div>
                    </div>
                `;
            }
            
            content.innerHTML = `
                <div class="site-info">
                    <div class="site-info-name-row">
                        <div class="site-info-name">${site.name}</div>
                        <button class="site-rename-btn" onclick="renameSite('${site.id}')" title="Rename site">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                        </button>
                    </div>
                    <div class="site-info-coords">${site.lat.toFixed(5)}, ${site.lng.toFixed(5)}</div>
                    ${parcelInfoHTML}
                    <div class="site-actions">
                        <button class="site-action-btn" onclick="rerunPOCDiscovery()">Re-scan</button>
                        <button class="site-action-btn" onclick="exportSiteReport('${site.id}')">Export PDF</button>
                        <button class="site-action-btn danger" onclick="deleteSite('${site.id}')">Delete</button>
                    </div>
                </div>
                
                <div class="poc-section-header">
                    <div class="poc-section-title">Connection Options</div>
                    <button class="add-custom-poc-btn${addCustomPOCMode ? ' active' : ''}" onclick="toggleAddCustomPOCMode()">
                        ${addCustomPOCMode ? 'Cancel' : '+ Add Custom'}
                    </button>
                </div>
                
                ${addCustomPOCMode ? `
                    <div class="add-custom-poc-instruction">
                        Click on any cable on the map to add a custom connection point
                    </div>
                ` : ''}
                
                ${site.pocs.length > 0 ? pocCardsHTML : `<div class="poc-empty">No connections found within ${Math.round(POC_MAX_DISTANCE_KM)}km.</div>`}
            `;
        }
        
        // Remove a POC from the current site
        function removePOC(pocId) {
            const site = sites.find(s => s.id === currentSiteId);
            if (!site) return;
            
            site.pocs = site.pocs.filter(p => p.id !== pocId);
            saveSitesToStorage();
            
            // Clear obstacle cache for this POC
            delete obstaclesCache[pocId];
            
            // Clear routed path for this POC
            if (routedPathLines[pocId]) {
                const lineOrLines = routedPathLines[pocId];
                if (Array.isArray(lineOrLines)) {
                    lineOrLines.forEach(line => map.removeLayer(line));
                } else {
                    map.removeLayer(lineOrLines);
                }
                delete routedPathLines[pocId];
            }
            
            // Clear route waypoint markers for this POC
            if (routeWaypointMarkers[pocId]) {
                routeWaypointMarkers[pocId].forEach(m => map.removeLayer(m));
                delete routeWaypointMarkers[pocId];
            }
            
            delete routedPaths[pocId];
            
            // Redraw visuals and panel
            clearPOCVisuals();
            drawPOCVisuals(site);
            renderSidePanel();
        }
        
        // Toggle custom POC mode
        function toggleAddCustomPOCMode() {
            addCustomPOCMode = !addCustomPOCMode;
            
            // Update map cursor
            const mapContainer = document.getElementById('map');
            if (addCustomPOCMode) {
                mapContainer.classList.add('add-poc-mode-active');
            } else {
                mapContainer.classList.remove('add-poc-mode-active');
            }
            
            renderSidePanel();
        }
        
        // Add a custom POC at a clicked location
        function addCustomPOC(latlng) {
            const site = sites.find(s => s.id === currentSiteId);
            if (!site) return;
            
            // Find the nearest cable point to where the user clicked
            const clickPoint = turf.point([latlng.lng, latlng.lat]);
            let nearestResult = null;
            let nearestDistance = Infinity;
            let nearestLayerConfig = null;
            let nearestLayerName = null;
            
            // Search all visible cable layers
            const visibleLayerNames = getVisibleLayerNames();
            
            visibleLayerNames.forEach(layerName => {
                const geoJSON = rawGeoJSONData[layerName];
                if (!geoJSON || !geoJSON.features) return;
                
                const layerConfig = getLayerConfig(layerName);
                if (!layerConfig) return;
                
                geoJSON.features.forEach(feature => {
                    if (!feature.geometry) return;
                    
                    try {
                        let candidatePoint = null;
                        let candidateDistance = Infinity;
                        
                        if (feature.geometry.type === 'LineString') {
                            const nearestOnLine = turf.nearestPointOnLine(feature, clickPoint, { units: 'meters' });
                            candidateDistance = nearestOnLine.properties.dist;
                            candidatePoint = {
                                lat: nearestOnLine.geometry.coordinates[1],
                                lng: nearestOnLine.geometry.coordinates[0]
                            };
                        } else if (feature.geometry.type === 'MultiLineString') {
                            feature.geometry.coordinates.forEach(lineCoords => {
                                try {
                                    const line = turf.lineString(lineCoords);
                                    const nearestOnLine = turf.nearestPointOnLine(line, clickPoint, { units: 'meters' });
                                    if (nearestOnLine.properties.dist < candidateDistance) {
                                        candidateDistance = nearestOnLine.properties.dist;
                                        candidatePoint = {
                                            lat: nearestOnLine.geometry.coordinates[1],
                                            lng: nearestOnLine.geometry.coordinates[0]
                                        };
                                    }
                                } catch (e) {}
                            });
                        }
                        
                        if (candidatePoint && candidateDistance < nearestDistance) {
                            nearestDistance = candidateDistance;
                            nearestResult = candidatePoint;
                            nearestLayerConfig = layerConfig;
                            nearestLayerName = layerName;
                        }
                    } catch (e) {}
                });
            });
            
            if (!nearestResult) {
                alert('No cables found nearby. Please try clicking closer to a cable.');
                return;
            }
            
            // Get voltage from layer name
            const voltage = extractVoltage(nearestLayerName);
            const powerRange = VOLTAGE_POWER_RANGES[voltage] || { min: 0, max: 0 };
            
            // Calculate distance from site to POC point
            const sitePoint = turf.point([site.lng, site.lat]);
            const pocPoint = turf.point([nearestResult.lng, nearestResult.lat]);
            const distance = turf.distance(sitePoint, pocPoint, { units: 'meters' });
            
            // Create the custom POC
            const customPOC = {
                id: generateId(),
                voltage: voltage,
                type: 'Cable',
                lat: nearestResult.lat,
                lng: nearestResult.lng,
                distance: distance,
                powerMin: powerRange.min,
                powerMax: powerRange.max,
                color: nearestLayerConfig?.color || '#6b7280',
                layerName: nearestLayerName,
                isCustom: true,
                waypoints: []
            };
            
            // Add to site
            site.pocs.push(customPOC);
            saveSitesToStorage();
            
            // Exit custom POC mode
            addCustomPOCMode = false;
            document.getElementById('map').classList.remove('add-poc-mode-active');
            
            // Redraw
            clearPOCVisuals();
            drawPOCVisuals(site);
            renderSidePanel();
        }
        
        // Delete a site
        function deleteSite(siteId) {
            
            // Remove marker
            if (siteMarkers[siteId]) {
                map.removeLayer(siteMarkers[siteId]);
                delete siteMarkers[siteId];
            }
            
            // Remove from array
            sites = sites.filter(s => s.id !== siteId);
            saveSitesToStorage();
            
            // Deselect if this was the current site
            if (currentSiteId === siteId) {
                currentSiteId = null;
                clearPOCVisuals();
            }
            
            // Update panel (will show list or hide if no sites)
            renderSidePanel();
        }
        
        // Re-run POC discovery for current site
        function rerunPOCDiscovery() {
            if (currentSiteId) {
                discoverPOCs(currentSiteId);
            }
        }
        
        // Export site report as PDF
        async function exportSiteReport(siteId) {
            const site = sites.find(s => s.id === siteId);
            if (!site) return;
            
            // Show loading state
            const exportBtn = document.querySelector('.site-action-btn:nth-child(2)');
            const originalText = exportBtn.textContent;
            exportBtn.textContent = 'Generating...';
            exportBtn.disabled = true;
            
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                
                // Colors
                const primaryColor = [15, 17, 18];
                const mutedColor = [102, 109, 112];
                
                // Header
                doc.setFontSize(24);
                doc.setTextColor(...primaryColor);
                doc.text('Site Connection Report', 20, 25);
                
                doc.setFontSize(10);
                doc.setTextColor(...mutedColor);
                doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 33);
                
                // Site Info
                doc.setFontSize(14);
                doc.setTextColor(...primaryColor);
                doc.text('Site Information', 20, 48);
                
                doc.setFontSize(11);
                doc.text(`Name: ${site.name}`, 25, 58);
                doc.text(`Coordinates: ${site.lat.toFixed(6)}, ${site.lng.toFixed(6)}`, 25, 66);
                doc.text(`Total POCs: ${site.pocs.length}`, 25, 74);
                
                // POC Table Header
                doc.setFontSize(14);
                doc.text('Connection Options', 20, 92);
                
                // Table
                const tableStartY = 100;
                const colWidths = [30, 30, 40, 70];
                const headers = ['Voltage', 'Type', 'Distance', 'Obstacles'];
                
                // Draw header row
                doc.setFillColor(235, 239, 240);
                doc.rect(20, tableStartY - 6, 170, 10, 'F');
                
                doc.setFontSize(9);
                doc.setTextColor(...primaryColor);
                let xPos = 22;
                headers.forEach((header, i) => {
                    doc.text(header, xPos, tableStartY);
                    xPos += colWidths[i];
                });
                
                // Draw data rows
                doc.setFontSize(9);
                let yPos = tableStartY + 12;
                
                site.pocs.forEach((poc, index) => {
                    // Alternate row backgrounds
                    if (index % 2 === 0) {
                        doc.setFillColor(250, 250, 250);
                        doc.rect(20, yPos - 5, 170, 10, 'F');
                    }
                    
                    xPos = 22;
                    
                    // Voltage
                    doc.setTextColor(...primaryColor);
                    doc.text(poc.voltage, xPos, yPos);
                    xPos += colWidths[0];
                    
                    // Type
                    doc.text(poc.type, xPos, yPos);
                    xPos += colWidths[1];
                    
                    // Distance
                    doc.text(formatDistance(poc.distance), xPos, yPos);
                    xPos += colWidths[2];
                    
                    // Obstacles
                    const obstacleDataPdf = obstaclesCache[poc.id];
                    let obstacleText = 'N/A';
                    if (obstacleDataPdf?.fetched) {
                        const count = (obstacleDataPdf.crossings?.length || 0) + (obstacleDataPdf.builtupAreas?.length || 0);
                        obstacleText = count > 0 ? `${count} detected` : 'None';
                    }
                    doc.text(obstacleText, xPos, yPos);
                    
                    yPos += 10;
                    
                    // Add new page if needed
                    if (yPos > 270) {
                        doc.addPage();
                        yPos = 20;
                    }
                });
                
                // Summary section
                yPos += 10;
                if (yPos > 240) {
                    doc.addPage();
                    yPos = 20;
                }
                
                doc.setFontSize(14);
                doc.setTextColor(...primaryColor);
                doc.text('Summary', 20, yPos);
                yPos += 12;
                
                // Find best option
                const sortedByDistance = [...site.pocs].sort((a, b) => a.distance - b.distance);
                
                doc.setFontSize(10);
                if (sortedByDistance.length > 0) {
                    const closest = sortedByDistance[0];
                    doc.text(`Closest connection: ${closest.voltage} ${closest.type} at ${formatDistance(closest.distance)}`, 25, yPos);
                    yPos += 8;
                }
                
                // Recommendations
                yPos += 8;
                doc.setFontSize(12);
                doc.text('Recommendations:', 25, yPos);
                yPos += 10;
                
                doc.setFontSize(10);
                doc.setTextColor(...mutedColor);
                
                const recommendations = [];
                
                // Check for high voltage options
                const highVoltage = site.pocs.filter(p => p.voltage === '132kV');
                if (highVoltage.length > 0) {
                    recommendations.push('High voltage 132kV connection available - suitable for large projects.');
                }
                
                // Check for obstacle-free options
                const obstacleFree = site.pocs.filter(p => {
                    const data = obstaclesCache[p.id];
                    return data?.fetched && (data.crossings?.length || 0) + (data.builtupAreas?.length || 0) === 0;
                });
                if (obstacleFree.length > 0) {
                    recommendations.push(`${obstacleFree.length} connection(s) with no detected obstacles - may offer simpler routing.`);
                }
                
                // Check distances
                const closeOptions = site.pocs.filter(p => p.distance < 1000);
                if (closeOptions.length > 0) {
                    recommendations.push(`${closeOptions.length} connection(s) within 1km - good proximity.`);
                }
                
                if (recommendations.length === 0) {
                    recommendations.push('Consider all options carefully based on project requirements.');
                }
                
                recommendations.forEach(rec => {
                    doc.text(` ${rec}`, 28, yPos, { maxWidth: 160 });
                    yPos += 10;
                });
                
                // Footer
                doc.setFontSize(8);
                doc.setTextColor(...mutedColor);
                doc.text('This report is for preliminary assessment only. Actual costs and feasibility should be confirmed with the DNO.', 20, 285);
                
                // Save the PDF
                doc.save(`${site.name.replace(/[^a-zA-Z0-9]/g, '_')}_connection_report.pdf`);
                
            } catch (error) {
                console.error('Error generating PDF:', error);
                alert('Error generating PDF. Please try again.');
            } finally {
                exportBtn.textContent = originalText;
                exportBtn.disabled = false;
            }
        }
        
        // ============== POC DISCOVERY ALGORITHM ==============
        
        // Extract voltage from layer name
        function extractVoltage(layerName) {
            if (layerName.includes('132kV')) return '132kV';
            if (layerName.includes('66kV')) return '66kV';
            if (layerName.includes('33kV')) return '33kV';
            if (layerName.includes('HV Network')) return 'HV Network';
            return null;
        }
        
        // Find nearest connection for each voltage level
        function findNearestPerVoltage(siteLat, siteLng, maxDistanceKm = POC_MAX_DISTANCE_KM) {
            const sitePoint = turf.point([siteLng, siteLat]);
            // Only search layers that match current MVA filter
            const visibleLayerNames = getVisibleLayerNames();
            
            // Track nearest per voltage
            const nearestPerVoltage = {};
            
            const searchBuffer = turf.buffer(sitePoint, maxDistanceKm, { units: 'kilometers' });
            const searchBbox = turf.bbox(searchBuffer);
            
            visibleLayerNames.forEach(layerName => {
                const geoJSON = rawGeoJSONData[layerName];
                if (!geoJSON || !geoJSON.features) return;
                
                const layerConfig = getLayerConfig(layerName);
                if (!layerConfig) return;
                
                const voltage = extractVoltage(layerName);
                if (!voltage) return;
                
                geoJSON.features.forEach((feature) => {
                    if (!feature.geometry) return;
                    
                    // Quick bounding box check
                    const featureBbox = turf.bbox(feature);
                    if (featureBbox[0] > searchBbox[2] || featureBbox[2] < searchBbox[0] ||
                        featureBbox[1] > searchBbox[3] || featureBbox[3] < searchBbox[1]) {
                        return;
                    }
                    
                    try {
                        let candidatePoint = null;
                        let candidateDistance = Infinity;
                        
                        // Handle LineString
                        if (feature.geometry.type === 'LineString') {
                            const nearest = turf.nearestPointOnLine(feature, sitePoint, { units: 'meters' });
                            candidateDistance = nearest.properties.dist;
                            if (candidateDistance <= maxDistanceKm * 1000) {
                                const coords = nearest.geometry.coordinates;
                                candidatePoint = { lat: coords[1], lng: coords[0] };
                            }
                        }
                        // Handle MultiLineString
                        else if (feature.geometry.type === 'MultiLineString') {
                            feature.geometry.coordinates.forEach(lineCoords => {
                                const line = turf.lineString(lineCoords);
                                const nearest = turf.nearestPointOnLine(line, sitePoint, { units: 'meters' });
                                if (nearest.properties.dist < candidateDistance) {
                                    candidateDistance = nearest.properties.dist;
                                    const coords = nearest.geometry.coordinates;
                                    candidatePoint = { lat: coords[1], lng: coords[0] };
                                }
                            });
                        }
                        
                        // Update tracking
                        if (candidatePoint && candidateDistance <= maxDistanceKm * 1000) {
                            const result = {
                                lat: candidatePoint.lat,
                                lng: candidatePoint.lng,
                                distance: candidateDistance,
                                layerConfig: layerConfig,
                                type: 'Cable'
                            };
                            
                            // Track nearest cable per voltage
                            if (!nearestPerVoltage[voltage] || candidateDistance < nearestPerVoltage[voltage].distance) {
                                nearestPerVoltage[voltage] = result;
                            }
                        }
                    } catch (e) {
                        // Skip invalid geometries
                    }
                });
            });
            
            // For each voltage with a result, try to snap to a nearby pole/tower (only if poles layer is enabled)
            if (polesTowersVisible) {
                Object.keys(nearestPerVoltage).forEach(voltage => {
                    const cableResult = nearestPerVoltage[voltage];
                    if (!cableResult) return;
                    
                    // Look for a pole/tower within 200m of the cable point
                    const nearestPole = findNearestPoleTower(cableResult.lat, cableResult.lng, voltage, 200);
                    
                    if (nearestPole) {
                        // Recalculate distance from site to pole
                        const polePoint = turf.point([nearestPole.lng, nearestPole.lat]);
                        const distanceFromSite = turf.distance(sitePoint, polePoint, { units: 'meters' });
                        
                        // Update result to snap to pole/tower
                        cableResult.lat = nearestPole.lat;
                        cableResult.lng = nearestPole.lng;
                        cableResult.distance = distanceFromSite;
                        cableResult.type = 'Pole/Tower';
                        cableResult.poleInfo = nearestPole.properties;
                    }
                });
            }
            
            return {
                nearestPerVoltage
            };
        }
        
        // Discover POCs for a site - find nearest connection per voltage level
        function discoverPOCs(siteId) {
            const site = sites.find(s => s.id === siteId);
            if (!site) return;
            
            // Show loading state
            const content = document.getElementById('side-panel-content');
            content.innerHTML = `
                <div class="poc-loading">
                    <div class="poc-loading-spinner"></div>
                    <div>Discovering points of connection...</div>
                </div>
            `;
            
            // Use setTimeout to allow UI to update
            setTimeout(() => {
                const { nearestPerVoltage } = findNearestPerVoltage(site.lat, site.lng);
                const discoveredPOCs = [];
                
                // Add all voltages
                const voltages = LAYERS.map(l => l.name);
                
                voltages.forEach(voltage => {
                    const nearest = nearestPerVoltage[voltage];
                    if (nearest) {
                        const powerRange = VOLTAGE_POWER_RANGES[voltage];
                        discoveredPOCs.push({
                            id: generateId(),
                            voltage: voltage,
                            lat: nearest.lat,
                            lng: nearest.lng,
                            distance: nearest.distance,
                            type: nearest.type,
                            layerName: nearest.layerConfig.name,
                            powerMin: powerRange.min,
                            powerMax: powerRange.max,
                            color: powerRange.color,
                            status: 'pending'
                        });
                    }
                });
                
                // Update site
                site.pocs = discoveredPOCs;
                saveSitesToStorage();
                
                // Redraw
                clearPOCVisuals();
                drawPOCVisuals(site);
                renderSidePanel();
            }, 100);
        }
        
        // ============== END SITE & POC FINDER FUNCTIONS ==============

        // Finish loading and show map
        function finishLoading() {
            // Add base map layer control only (no overlays)
            // Track previous base map for keyboard shortcuts
            let previousBaseMap = currentBaseMap;
            let isSatelliteShortcutActive = false;
            let isColourShortcutActive = false;
            let isLightShortcutActive = false;
            
            // Keyboard shortcuts: hold 's' for satellite, 'c' for colour, 'l' for light
            document.addEventListener('keydown', function(e) {
                // Ignore if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                // Satellite shortcut (s key)
                if (e.key === 's' || e.key === 'S') {
                    if (!isSatelliteShortcutActive && !isColourShortcutActive && !isLightShortcutActive) {
                        isSatelliteShortcutActive = true;
                        previousBaseMap = currentBaseMap;
                        
                        // Switch to satellite
                        Object.keys(baseMaps).forEach(key => {
                            if (map.hasLayer(baseMaps[key])) {
                                map.removeLayer(baseMaps[key]);
                            }
                        });
                        baseMaps['Satellite'].addTo(map);
                        currentBaseMap = 'Satellite';
                        updateMapLayerSelection('Satellite');
                    }
                }
                
                // Colour shortcut (c key)
                if (e.key === 'c' || e.key === 'C') {
                    if (!isColourShortcutActive && !isSatelliteShortcutActive && !isLightShortcutActive) {
                        isColourShortcutActive = true;
                        previousBaseMap = currentBaseMap;
                        
                        // Switch to colour
                        Object.keys(baseMaps).forEach(key => {
                            if (map.hasLayer(baseMaps[key])) {
                                map.removeLayer(baseMaps[key]);
                            }
                        });
                        baseMaps['Colour'].addTo(map);
                        currentBaseMap = 'Colour';
                        updateMapLayerSelection('Colour');
                    }
                }
                
                // Light shortcut (l key)
                if (e.key === 'l' || e.key === 'L') {
                    if (!isLightShortcutActive && !isSatelliteShortcutActive && !isColourShortcutActive) {
                        isLightShortcutActive = true;
                        previousBaseMap = currentBaseMap;
                        
                        // Switch to light
                        Object.keys(baseMaps).forEach(key => {
                            if (map.hasLayer(baseMaps[key])) {
                                map.removeLayer(baseMaps[key]);
                            }
                        });
                        baseMaps['Light'].addTo(map);
                        currentBaseMap = 'Light';
                        updateMapLayerSelection('Light');
                    }
                }
            });
            
            document.addEventListener('keyup', function(e) {
                // Satellite shortcut release
                if ((e.key === 's' || e.key === 'S') && isSatelliteShortcutActive) {
                    isSatelliteShortcutActive = false;
                    
                    // Revert to previous base map
                    if (map.hasLayer(baseMaps['Satellite'])) {
                        map.removeLayer(baseMaps['Satellite']);
                    }
                    baseMaps[previousBaseMap].addTo(map);
                    currentBaseMap = previousBaseMap;
                    updateMapLayerSelection(previousBaseMap);
                }
                
                // Colour shortcut release
                if ((e.key === 'c' || e.key === 'C') && isColourShortcutActive) {
                    isColourShortcutActive = false;
                    
                    // Revert to previous base map
                    if (map.hasLayer(baseMaps['Colour'])) {
                        map.removeLayer(baseMaps['Colour']);
                    }
                    baseMaps[previousBaseMap].addTo(map);
                    currentBaseMap = previousBaseMap;
                    updateMapLayerSelection(previousBaseMap);
                }
                
                // Light shortcut release
                if ((e.key === 'l' || e.key === 'L') && isLightShortcutActive) {
                    isLightShortcutActive = false;
                    
                    // Revert to previous base map
                    if (map.hasLayer(baseMaps['Light'])) {
                        map.removeLayer(baseMaps['Light']);
                    }
                    baseMaps[previousBaseMap].addTo(map);
                    currentBaseMap = previousBaseMap;
                    updateMapLayerSelection(previousBaseMap);
                }
            });
            
            // Add filter panel (left side, above POC button)
            const filterPanel = L.control({ position: 'topleft' });
            filterPanel.onAdd = function() {
                const div = L.DomUtil.create('div', 'filter-panel');
                
                // Build cable layer indicators HTML by voltage level
                let cableIndicatorsHTML = LAYERS.map(layerConfig => {
                    const id = layerConfig.name.replace(/\./g, 'p').replace(/[^a-zA-Z0-9p]/g, '');
                    return `
                        <div class="layer-indicator" id="indicator-${id}">
                            <span class="layer-dot" style="background: ${layerConfig.color}"></span>
                            <span>${layerConfig.name}</span>
                            <span class="layer-mva">${layerConfig.mvaMin}-${layerConfig.mvaMax}</span>
                        </div>
                    `;
                }).join('');
                
                
                div.innerHTML = `
                    <div class="location-search">
                        <div class="location-search-title">Search Location</div>
                        <div class="location-search-input-wrapper">
                            <svg class="location-search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="11" cy="11" r="8"></circle>
                                <path d="m21 21-4.35-4.35"></path>
                            </svg>
                            <input type="text" 
                                   class="location-search-input" 
                                   id="location-search-input"
                                   placeholder="Enter address or postcode..."
                                   autocomplete="off">
                            <button class="location-search-clear" id="location-search-clear" title="Clear search"></button>
                        </div>
                        <div class="location-search-results" id="location-search-results"></div>
                    </div>
                    
                    <div class="filter-section">
                        <h4>Project Size</h4>
                        <p class="subtitle">Filter networks by connection capacity (MVA)</p>
                        
                        <div class="mva-display">
                            <div class="mva-value">
                                <div class="label">Min</div>
                                <div class="number" id="mva-min">${formatMVA(filterMin)}</div>
                            </div>
                            <div class="mva-separator">to</div>
                            <div class="mva-value">
                                <div class="label">Max</div>
                                <div class="number" id="mva-max">${formatMVA(filterMax)}</div>
                            </div>
                        </div>
                        
                        <div class="slider-container">
                            <div id="mva-slider"></div>
                        </div>
                    </div>
                    
                    <div class="filter-section">
                        <h4>Max POC Distance</h4>
                        <p class="subtitle">Maximum search radius for finding connections</p>
                        
                        <div class="mva-display">
                            <div class="mva-value">
                                <div class="label">Radius</div>
                                <div class="number" id="poc-distance-display">${POC_MAX_DISTANCE_KM} km</div>
                            </div>
                        </div>
                        
                        <div class="slider-container">
                            <div id="poc-distance-slider"></div>
                        </div>
                    </div>
                    
                    <div class="map-layers">
                        <div class="map-layers-title">Map View</div>
                        <div class="map-layer-option ${currentBaseMap === 'Light' ? 'selected' : ''}" data-layer="Light">
                            <span>Light</span>
                            <span class="shortcut">Hold L</span>
                        </div>
                        <div class="map-layer-option ${currentBaseMap === 'Colour' ? 'selected' : ''}" data-layer="Colour">
                            <span>Colour</span>
                            <span class="shortcut">Hold C</span>
                        </div>
                        <div class="map-layer-option ${currentBaseMap === 'Satellite' ? 'selected' : ''}" data-layer="Satellite">
                            <span>Satellite</span>
                            <span class="shortcut">Hold S</span>
                        </div>
                    </div>
                    
                    <div class="active-layers">
                        <div class="active-layers-title">Cables</div>
                        ${cableIndicatorsHTML}
                    </div>
                    
                    <div class="active-layers" style="margin-top: 8px;">
                        <div class="active-layers-title">EHV Supports</div>
                        <div class="layer-indicator layer-toggle hidden" id="toggle-poles-towers" style="cursor: pointer;">
                            <span class="layer-dot" style="background: transparent; border: 2px solid #f97316; width: 8px; height: 8px;"></span>
                            <span>33/66/132kV Supports</span>
                            <span class="layer-toggle-check" style="margin-left: auto; opacity: 0.3;"></span>
                        </div>
                        <div style="font-size: 10px; color: #9ca3af; padding: 4px 0 0 14px;">POC finder snaps to supports when enabled</div>
                    </div>
                `;
                
                // Prevent map interactions when using the slider
                L.DomEvent.disableClickPropagation(div);
                L.DomEvent.disableScrollPropagation(div);
                
                return div;
            };
            filterPanel.addTo(map);
            
            // Function to update selected map layer in UI
            function updateMapLayerSelection(selectedLayer) {
                const options = document.querySelectorAll('.map-layer-option');
                if (options.length === 0) return; // Panel not yet rendered
                options.forEach(option => {
                    if (option.dataset.layer === selectedLayer) {
                        option.classList.add('selected');
                    } else {
                        option.classList.remove('selected');
                    }
                });
            }
            
            // Add click handlers for map layer options
            setTimeout(() => {
                const mapLayerOptions = document.querySelectorAll('.map-layer-option');
                mapLayerOptions.forEach(option => {
                    option.addEventListener('click', function() {
                        const layerName = this.dataset.layer;
                        if (layerName !== currentBaseMap && !isSatelliteShortcutActive && !isColourShortcutActive && !isLightShortcutActive) {
                            // Remove all base layers
                            Object.keys(baseMaps).forEach(key => {
                                if (map.hasLayer(baseMaps[key])) {
                                    map.removeLayer(baseMaps[key]);
                                }
                            });
                            // Add selected layer
                            baseMaps[layerName].addTo(map);
                            currentBaseMap = layerName;
                            previousBaseMap = layerName;
                            updateMapLayerSelection(layerName);
                        }
                    });
                });
                
                // Add click handler for EHV supports toggle (lazy-loads data on first enable)
                const polesTowersToggle = document.getElementById('toggle-poles-towers');
                if (polesTowersToggle) {
                    polesTowersToggle.addEventListener('click', async function() {
                        polesTowersVisible = !polesTowersVisible;
                        const checkmark = this.querySelector('.layer-toggle-check');
                        checkmark.style.opacity = polesTowersVisible ? '1' : '0.3';
                        
                        // Lazy-load supports data on first enable
                        if (polesTowersVisible && !supportsLoaded) {
                            this.querySelector('span:nth-child(2)').textContent = 'Loading supports...';
                            await loadSupportsData();
                            this.querySelector('span:nth-child(2)').textContent = '33/66/132kV Supports';
                        }
                        
                        updateLayerVisibility();
                    });
                }
                
                // Location search functionality
                const locationSearchInput = document.getElementById('location-search-input');
                const locationSearchResults = document.getElementById('location-search-results');
                const locationSearchClear = document.getElementById('location-search-clear');
                let searchTimeout = null;
                let searchMarker = null;
                
                if (locationSearchInput && locationSearchResults && locationSearchClear) {
                    // Clear button functionality
                    locationSearchClear.addEventListener('click', function() {
                        locationSearchInput.value = '';
                        locationSearchResults.classList.remove('visible');
                        locationSearchClear.classList.remove('visible');
                        if (searchMarker) {
                            map.removeLayer(searchMarker);
                            searchMarker = null;
                        }
                    });
                    
                    // Update clear button visibility based on input
                    locationSearchInput.addEventListener('input', function() {
                        const query = this.value.trim();
                        
                        // Show/hide clear button
                        if (query.length > 0) {
                            locationSearchClear.classList.add('visible');
                        } else {
                            locationSearchClear.classList.remove('visible');
                            locationSearchResults.classList.remove('visible');
                        }
                        
                        // Debounce search
                        if (searchTimeout) {
                            clearTimeout(searchTimeout);
                        }
                        
                        if (query.length >= 3) {
                            // Show loading state
                            locationSearchResults.innerHTML = '<div class="location-search-loading">Searching</div>';
                            locationSearchResults.classList.add('visible');
                            
                            searchTimeout = setTimeout(() => {
                                performLocationSearch(query);
                            }, 300);
                        } else {
                            locationSearchResults.classList.remove('visible');
                        }
                    });
                    
                    // Hide results when clicking outside
                    document.addEventListener('click', function(e) {
                        if (!e.target.closest('.location-search')) {
                            locationSearchResults.classList.remove('visible');
                        }
                    });
                    
                    // Show results on focus if there's content
                    locationSearchInput.addEventListener('focus', function() {
                        if (this.value.trim().length >= 3 && locationSearchResults.innerHTML && !locationSearchResults.innerHTML.includes('location-search-loading')) {
                            locationSearchResults.classList.add('visible');
                        }
                    });
                    
                    // Perform location search using Nominatim
                    async function performLocationSearch(query) {
                        try {
                            // Bias search towards UK
                            const params = new URLSearchParams({
                                q: query,
                                format: 'json',
                                addressdetails: '1',
                                limit: '6',
                                countrycodes: 'gb',
                                viewbox: '-8.0,49.5,2.0,59.0',
                                bounded: '0'
                            });
                            
                            const response = await fetch(`https://nominatim.openstreetmap.org/search?${params}`, {
                                headers: {
                                    'Accept': 'application/json'
                                }
                            });
                            
                            if (!response.ok) {
                                throw new Error('Search failed');
                            }
                            
                            const results = await response.json();
                            displaySearchResults(results);
                        } catch (error) {
                            console.error('Location search error:', error);
                            locationSearchResults.innerHTML = '<div class="location-search-no-results">Search failed. Please try again.</div>';
                        }
                    }
                    
                    // Display search results
                    function displaySearchResults(results) {
                        if (results.length === 0) {
                            locationSearchResults.innerHTML = '<div class="location-search-no-results">No locations found</div>';
                            return;
                        }
                        
                        const html = results.map(result => {
                            // Extract meaningful name and address
                            const address = result.address || {};
                            let name = result.name || address.road || address.village || address.town || address.city || 'Unknown';
                            
                            // Build display address
                            const addressParts = [];
                            if (address.road && address.road !== name) addressParts.push(address.road);
                            if (address.village) addressParts.push(address.village);
                            if (address.town && address.town !== address.village) addressParts.push(address.town);
                            if (address.city && address.city !== address.town) addressParts.push(address.city);
                            if (address.county) addressParts.push(address.county);
                            if (address.postcode) addressParts.push(address.postcode);
                            
                            const displayAddress = addressParts.slice(0, 3).join(', ');
                            
                            return `
                                <div class="location-search-result" 
                                     data-lat="${result.lat}" 
                                     data-lon="${result.lon}"
                                     data-name="${name.replace(/"/g, '&quot;')}">
                                    <div class="location-search-result-name">${name}</div>
                                    <div class="location-search-result-address">${displayAddress}</div>
                                </div>
                            `;
                        }).join('');
                        
                        locationSearchResults.innerHTML = html;
                        
                        // Add click handlers to results
                        locationSearchResults.querySelectorAll('.location-search-result').forEach(resultEl => {
                            resultEl.addEventListener('click', function() {
                                const lat = parseFloat(this.dataset.lat);
                                const lon = parseFloat(this.dataset.lon);
                                const name = this.dataset.name;
                                
                                selectSearchResult(lat, lon, name);
                            });
                        });
                    }
                    
                    // Handle selection of a search result
                    function selectSearchResult(lat, lon, name) {
                        // Remove existing search marker if any
                        if (searchMarker) {
                            map.removeLayer(searchMarker);
                        }
                        
                        // Create a marker at the selected location
                        searchMarker = L.marker([lat, lon], {
                            icon: L.divIcon({
                                className: 'search-location-marker',
                                html: `<div style="
                                    width: 8px;
                                    height: 8px;
                                    background: #0f1112;
                                    transform: translate(-50%, -50%);
                                "></div>`,
                                iconSize: [8, 8],
                                iconAnchor: [4, 4]
                            })
                        }).addTo(map);
                        
                        // Add popup to marker
                        searchMarker.bindPopup(`
                            <div class="popup-content">
                                <strong>${name}</strong>
                            </div>
                        `).openPopup();
                        
                        // Pan and zoom to the location
                        map.setView([lat, lon], 15);
                        
                        // Update input and hide results
                        locationSearchInput.value = name;
                        locationSearchResults.classList.remove('visible');
                    }
                }
                
            }, 100);
            
            // Initialize the slider after the panel is added to DOM
            setTimeout(() => {
                const slider = document.getElementById('mva-slider');
                
                noUiSlider.create(slider, {
                    start: [filterMin, filterMax],
                    connect: true,
                    range: {
                        'min': [0.1],
                        '15%': [1],
                        '30%': [5],
                        '50%': [20],
                        '70%': [50],
                        'max': [100]
                    },
                    tooltips: false,
                    pips: {
                        mode: 'values',
                        values: [0.1, 1, 5, 20, 50, 100],
                        density: 10,
                        format: {
                            to: (v) => v >= 1 ? v.toFixed(0) : v.toFixed(1)
                        }
                    }
                });
                
                // Customize handle styling after creation
                const handles = slider.querySelectorAll('.noUi-handle');
                handles.forEach(handle => {
                    handle.style.width = '8px';
                    handle.style.height = '8px';
                    handle.style.borderRadius = '2px';
                    // Background set via CSS for theme support
                    handle.style.border = 'none';
                    handle.style.boxShadow = 'none';
                    handle.style.top = '0px';
                    handle.style.right = '-4px';
                    handle.style.boxSizing = 'border-box';
                });
                
                slider.noUiSlider.on('update', function(values) {
                    filterMin = parseFloat(values[0]);
                    filterMax = parseFloat(values[1]);
                    updateMVADisplay();
                    updateLayerVisibility();
                });
                
                // Apply initial filter
                updateLayerVisibility();
                
                // Initialize max POC distance slider
                const distSlider = document.getElementById('poc-distance-slider');
                
                noUiSlider.create(distSlider, {
                    start: [POC_MAX_DISTANCE_KM],
                    connect: [true, false],
                    range: {
                        'min': [1],
                        '25%': [5],
                        '50%': [15],
                        '75%': [30],
                        'max': [100]
                    },
                    tooltips: false,
                    pips: {
                        mode: 'values',
                        values: [1, 5, 15, 30, 50, 100],
                        density: 10,
                        format: {
                            to: (v) => v >= 10 ? v.toFixed(0) : v.toFixed(0)
                        }
                    }
                });
                
                // Style the handle to match the MVA slider
                const distHandles = distSlider.querySelectorAll('.noUi-handle');
                distHandles.forEach(handle => {
                    handle.style.width = '8px';
                    handle.style.height = '8px';
                    handle.style.borderRadius = '2px';
                    handle.style.border = 'none';
                    handle.style.boxShadow = 'none';
                    handle.style.top = '0px';
                    handle.style.right = '-4px';
                    handle.style.boxSizing = 'border-box';
                });
                
                distSlider.noUiSlider.on('update', function(values) {
                    POC_MAX_DISTANCE_KM = parseFloat(values[0]);
                    const displayEl = document.getElementById('poc-distance-display');
                    if (displayEl) {
                        displayEl.textContent = `${Math.round(POC_MAX_DISTANCE_KM)} km`;
                    }
                });
            }, 100);
            
            // Load saved sites from localStorage and show markers
            loadSitesFromStorage();
            sites.forEach(site => {
                siteMarkers[site.id] = createSiteMarker(site);
                siteMarkers[site.id].addTo(map);
            });
            
            // Show side panel with site list if sites exist
            renderSidePanel();
            
            // Fit to bounds if we have data
            if (allBounds && allBounds.isValid()) {
                map.fitBounds(allBounds, { padding: [20, 20] });
            }
            
            // Default one-off POC on map click (lightweight alternative to POC mode)
            map.on('click', handleSinglePOCClick);
            
            // Add zoom handler to update pole/tower marker sizes
            map.on('zoomend', () => {
                updatePoleTowerSizes();
            });
            
            // Initial size update
            updatePoleTowerSizes();
            
            // Hide loading overlay
            document.getElementById('loading').classList.add('hidden');
        }

        // Load supports data lazily (only when user toggles on the supports layer)
        async function loadSupportsData() {
            if (supportsLoaded) return;
            supportsLoaded = true;
            
            try {
                console.log('Loading supports data (this may take a moment due to file size)...');
                const response = await fetch(SUPPORTS_FILE);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                
                // Initialize layer groups for each EHV voltage
                POLE_TOWER_LAYERS.forEach(layerConfig => {
                    const layerGroup = L.layerGroup();
                    poleTowerLayerGroups[layerConfig.voltage] = layerGroup;
                    poleTowerData[layerConfig.voltage] = [];
                });
                
                // Distribute features by voltage
                // Uses canvas-rendered circleMarkers instead of DOM-based divIcons
                // for dramatically better performance with 70K+ features
                data.features.forEach(feature => {
                    if (!feature.geometry || feature.geometry.type !== 'Point') return;
                    
                    const volts = feature.properties.voltage;
                    if (!volts) return;
                    
                    // Find matching pole/tower layer
                    const layerConfig = POLE_TOWER_LAYERS.find(l => l.voltageVolts === volts);
                    if (!layerConfig) return;  // Skip HV voltages for supports display
                    
                    // Store for POC snapping
                    poleTowerData[layerConfig.voltage].push(feature);
                    
                    const coords = feature.geometry.coordinates;
                    const props = feature.properties || {};
                    
                    // Create canvas-rendered circle marker (much faster than DOM divIcon)
                    const marker = L.circleMarker([coords[1], coords[0]], {
                        radius: 4,
                        color: layerConfig.color,
                        weight: 1.5,
                        opacity: 0.8,
                        fillColor: 'transparent',
                        fillOpacity: 0
                    });
                    
                    // Add popup with support info
                    const supportType = props.support_type || 'Support';
                    const supportHeight = props.support_height || 'Unknown';
                    const dnoArea = props.dno_area || 'Unknown';
                    marker.bindPopup(`
                        <div class="popup-content">
                            <span class="voltage-badge" style="background-color: ${layerConfig.color}">${layerConfig.voltage}</span>
                            <div><strong>Type:</strong> ${supportType}</div>
                            <div><strong>Height:</strong> ${supportHeight}</div>
                            <div><strong>Area:</strong> ${dnoArea}</div>
                        </div>
                    `);
                    
                    poleTowerLayerGroups[layerConfig.voltage].addLayer(marker);
                });
                
                console.log('Supports data loaded successfully');
                // Apply visibility after loading
                updateLayerVisibility();
                
                return true;
            } catch (error) {
                console.error('Failed to load supports data:', error);
                supportsLoaded = false;
                return false;
            }
        }
        
        // Find nearest pole/tower to a given point for a specific voltage
        function findNearestPoleTower(lat, lng, voltage, maxDistanceMeters = 200) {
            const features = poleTowerData[voltage];
            if (!features || features.length === 0) return null;
            
            const targetPoint = turf.point([lng, lat]);
            let nearestPole = null;
            let nearestDistance = Infinity;
            
            features.forEach(feature => {
                if (!feature.geometry || feature.geometry.type !== 'Point') return;
                
                const polePoint = turf.point(feature.geometry.coordinates);
                const distance = turf.distance(targetPoint, polePoint, { units: 'meters' });
                
                if (distance < nearestDistance && distance <= maxDistanceMeters) {
                    nearestDistance = distance;
                    nearestPole = {
                        lat: feature.geometry.coordinates[1],
                        lng: feature.geometry.coordinates[0],
                        distance: distance,
                        properties: feature.properties
                    };
                }
            });
            
            return nearestPole;
        }

        // Load all layers
        async function init() {
            // Load all data sources in parallel
            await Promise.all(DATA_SOURCES.map(loadDataSource));
            
            // Build Leaflet layers from collected data
            buildVoltageLayers();
        }

        // Start loading
        init();
    </script>
</body>
</html>
